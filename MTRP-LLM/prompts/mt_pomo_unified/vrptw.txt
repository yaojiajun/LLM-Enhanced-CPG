1:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows:torch.Tensor, current_time:torch.Tensor) -> torch.Tensor:

    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Distance-based scoring with enhanced softmax function and noise injection
    distance_scores = torch.softmax(-current_distance_matrix, dim=1) + 0.1 * torch.randn_like(current_distance_matrix)

    # Load balance penalty with dynamic imbalance factor and stochastic adjustment
    mean_demand = delivery_node_demands[1:].mean()
    imbalance_factor = torch.abs(current_load.unsqueeze(1) - delivery_node_demands) / torch.clamp(mean_demand, min=0.1)
    load_balance_scores = -3.0 * imbalance_factor + 0.25 * torch.randn_like(current_distance_matrix)
    # Time window adherence scoring with personalized weights and dynamic waiting time
    arrival_time = current_time.unsqueeze(1) + current_distance_matrix
    lateness = torch.clamp(arrival_time - time_windows[:, 1].unsqueeze(0), max=0)
    waiting_time = torch.clamp(time_windows[:, 0].unsqueeze(0) + 3.0 - arrival_time, max=0)
    time_window_scores = torch.exp(-lateness.abs() * 3.5) * torch.exp(-waiting_time * 1.7) + 0.35 * torch.randn_like(current_distance_matrix)

    # Combined scores with optimized weight ratios
    combined_scores = 0.45 * distance_scores + 0.3 * load_balance_scores + 0.25 * time_window_scores

    # Penalize infeasible edges based on load capacity constraint
    infeasible_mask = current_load.unsqueeze(1) < delivery_node_demands
    heuristic_scores[infeasible_mask] = -4.2

    # Injected Gaussian noise for exploration enhancement
    noise_amplitude = 5.0 * torch.exp(-0.006 * current_time.max())
    heuristic_scores += noise_amplitude * torch.randn_like(heuristic_scores)

    return heuristic_scores

2:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows:torch.Tensor, current_time:torch.Tensor) -> torch.Tensor:

    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Distance-based scoring with enhanced temperature adaptation and noise control
    temperature = 0.09 + torch.sigmoid(0.005 * current_time.max())
    distance_scores = torch.softmax(-current_distance_matrix / (temperature + 0.03), dim=1) + 0.15 * torch.randn_like(current_distance_matrix)

    # Load balance penalty with adaptive scaling and diversity integration
    mean_demand = delivery_node_demands[1:].mean()
    load_balance_factor = current_load.unsqueeze(1) / torch.clamp(delivery_node_demands, min=0.03, max=mean_demand*2.0)
    load_balance_scores = torch.where(load_balance_factor < 1.5,
                                      -2.6 * load_balance_factor ** 2.0,
                                      0.5 * torch.abs(1.0 - load_balance_factor)) + 0.25 * torch.randn_like(current_distance_matrix)

    # Time window feasibility scoring with adjusted weights and dynamic waiting time calculation
    estimated_arrival = current_time.unsqueeze(1) + current_distance_matrix
    lateness = torch.clamp(estimated_arrival - time_windows[:, 1].unsqueeze(0), max=0)
    waiting_time = torch.clamp(time_windows[:, 0].unsqueeze(0) + 2.4 - estimated_arrival, max=0)  # Enhanced waiting time impact
    time_window_scores = torch.exp(-lateness.abs() * 2.8) * torch.exp(-waiting_time * 2.3) + 0.25 * torch.randn_like(current_distance_matrix)

    # Combined scores with tuned coefficients
    combined_scores = 0.4 * distance_scores + 0.25 * load_balance_scores + 0.35 * time_window_scores

    # Penalty for infeasible edges based on load constraints with adjusted penalty factor
    infeasible_mask = current_load.unsqueeze(1) < delivery_node_demands
    heuristic_scores[infeasible_mask] = -4.5

    # Exploration enhancement by injecting weighted Gaussian noise
    exploration_noise = 6.0 * torch.exp(-0.01 * current_time.max())
    heuristic_scores += exploration_noise * torch.randn_like(heuristic_scores)

    return heuristic_scores

3:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows:torch.Tensor, current_time:torch.Tensor) -> torch.Tensor:

    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Distance-based scoring with adaptive temperature and noise perturbation
    temperature = 0.05 + torch.sigmoid(0.001 * current_time.max())
    distance_scores = torch.softmax(-current_distance_matrix / temperature, dim=1) + 0.2 * torch.randn_like(current_distance_matrix)

    # Load balance penalty with refined imbalance factor and dynamic scaling
    mean_demand = delivery_node_demands[1:].mean()
    load_balance_factor = current_load.unsqueeze(1) / torch.clamp(delivery_node_demands, min=0.1, max=mean_demand*1.4)
    load_balance_scores = torch.where(load_balance_factor < 1.0,
                                      -1.5 * load_balance_factor ** 2.0,
                                      0.15 * torch.abs(1.0 - load_balance_factor)) + 0.4 * torch.randn_like(current_distance_matrix)

    # Time window feasibility scoring with adjusted weights and dynamic waiting time computation
    pickup_time = current_time.unsqueeze(1) + current_distance_matrix
    wait_time = torch.clamp(time_windows[:, 0].unsqueeze(0) - pickup_time, min=0)
    lateness = torch.clamp(pickup_time - time_windows[:, 1].unsqueeze(0), max=0)
    time_window_scores = torch.exp(-lateness.abs() * 2.5) * torch.exp(-wait_time * 2.0) + 0.15 * torch.randn_like(current_distance_matrix)

    # Combined scores with dynamically adjusted coefficients
    combined_scores = 0.4 * distance_scores + 0.25 * load_balance_scores + 0.35 * time_window_scores

    # Penalty for infeasible edges based on load constraints with adjusted penalty factor
    infeasible_mask = current_load.unsqueeze(1) < delivery_node_demands
    heuristic_scores[infeasible_mask] = -4.0

    # Exploration enhancement by injecting weighted Gaussian noise with dynamic factor
    exploration_noise = 5.0 * torch.exp(-0.002 * current_time.max())
    heuristic_scores += exploration_noise * torch.randn_like(heuristic_scores)

    return heuristic_scores

4:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows:torch.Tensor, current_time:torch.Tensor) -> torch.Tensor:

    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Distance-based scoring with fine-tuned temperature and noise perturbation
    temperature = 0.12 + torch.sigmoid(0.001 * current_time.max())
    distance_scores = torch.softmax(-current_distance_matrix / temperature, dim=1) + 0.15 * torch.randn_like(current_distance_matrix)

    # Load balance penalty with further refined imbalance and scaling
    mean_demand = delivery_node_demands[1:].mean()
    load_balance_factor = current_load.unsqueeze(1) / torch.clamp(delivery_node_demands, min=0.1, max=mean_demand*1.8)
    load_balance_scores = torch.where(load_balance_factor < 1.2,
                                      -4.5 * load_balance_factor ** 2.2,
                                      0.4 * torch.abs(1.0 - load_balance_factor)) + 0.15 * torch.randn_like(current_distance_matrix)

    # Time window feasibility scoring with adjusted weights and waiting time computation
    earliest_arrival = current_time.unsqueeze(1) + current_distance_matrix
    time_window_deviation = torch.maximum(earliest_arrival - time_windows[:, 1].unsqueeze(0), time_windows[:, 0].unsqueeze(0) - earliest_arrival)
    waiting_time = torch.clamp(time_windows[:, 1].unsqueeze(0) - earliest_arrival, max=0)
    time_window_scores = torch.exp(-time_window_deviation.abs() * 5.0) * torch.exp(-waiting_time * 3.5) + 0.25 * torch.randn_like(current_distance_matrix)

    # Combined scores with adjusted coefficients
    combined_scores = 0.55 * distance_scores + 0.2 * load_balance_scores + 0.25 * time_window_scores

    # Penalty for infeasible edges based on load constraints with adaptive penalty factor
    infeasible_mask = current_load.unsqueeze(1) < delivery_node_demands
    heuristic_scores[infeasible_mask] = -5.0

    # Exploration enhancement by injecting scaled Gaussian noise with temperature dependency
    exploration_noise = 6.0 * torch.exp(-0.005 * current_time.max())
    heuristic_scores += exploration_noise * torch.randn_like(heuristic_scores)

    return heuristic_scores

5:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows:torch.Tensor, current_time:torch.Tensor) -> torch.Tensor:
    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    temperature = 0.1 + torch.sigmoid(0.002 * current_time.max())
    distance_scores = torch.softmax(-current_distance_matrix / temperature, dim=1) + 0.1 * torch.randn_like(current_distance_matrix)

    mean_demand = delivery_node_demands[1:].mean()
    load_balance_factor = current_load.unsqueeze(1) / torch.clamp(delivery_node_demands, min=0.2, max=mean_demand*1.5)
    load_balance_scores = torch.where(load_balance_factor < 1.2,
                                      -4.0 * load_balance_factor ** 2.0,
                                      0.5 * torch.abs(1.0 - load_balance_factor)) + 0.2 * torch.randn_like(current_distance_matrix)

    earliest_arrival = current_time.unsqueeze(1) + current_distance_matrix
    lateness = torch.clamp(earliest_arrival - time_windows[:, 1].unsqueeze(0), max=0)
    waiting_time = torch.clamp(time_windows[:, 0].unsqueeze(0) + 3.5 - earliest_arrival, max=0)
    time_window_scores = torch.exp(-lateness.abs() * 3.0) * torch.exp(-waiting_time * 2.5) + 0.3 * torch.randn_like(current_distance_matrix)

    load_exceed_mask = current_load.unsqueeze(1) + delivery_node_demands > mean_demand*1.5
    load_exceed_scores = torch.where(load_exceed_mask,
                                     -3.0 * (load_balance_factor - 1.0) ** 2.0,
                                     torch.zeros_like(current_distance_matrix))

    combined_scores = 0.4 * distance_scores + 0.3 * load_balance_scores + 0.25 * time_window_scores + 0.05 * load_exceed_scores

    infeasible_mask = current_load.unsqueeze(1) < delivery_node_demands
    heuristic_scores[infeasible_mask] = -4.0

    exploration_noise = 6.0 * torch.exp(-0.01 * current_time.max())
    heuristic_scores += exploration_noise * torch.randn_like(heuristic_scores)

    return heuristic_scores

6:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows:torch.Tensor, current_time:torch.Tensor) -> torch.Tensor:
    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Distance-based scoring with modified temperature and noise injection
    temperature = 0.2 + torch.sigmoid(0.005 * current_time.max())
    distance_scores = torch.softmax(-current_distance_matrix / temperature, dim=1) + 0.15 * torch.randn_like(current_distance_matrix)

    # Load balance penalty with adaptive factor and refined imbalance calculation
    mean_demand = delivery_node_demands[1:].mean()
    load_balance_factor = current_load.unsqueeze(1) / torch.clamp(delivery_node_demands, min=0.2, max=mean_demand*1.5)
    load_balance_scores = torch.where(load_balance_factor < 1.0,
                                      -2.8 * load_balance_factor ** 2.2,
                                      0.6 * torch.abs(1.0 - load_balance_factor)) + 0.25*torch.randn_like(current_distance_matrix)

    # Time window feasibility scoring with adjusted weights and dynamic waiting time computation
    earliest_arrival = current_time.unsqueeze(1) + current_distance_matrix
    lateness = torch.clamp(earliest_arrival - time_windows[:, 1].unsqueeze(0), max=0)
    waiting_time = torch.clamp(time_windows[:, 0].unsqueeze(0) + 3.5 - earliest_arrival, max=0)  # Dynamic waiting time impact
    time_window_scores = torch.exp(-lateness.abs() * 3.0) * torch.exp(-waiting_time * 2.5) + 0.35*torch.randn_like(current_distance_matrix)

    # Combined scores with adjusted coefficients
    combined_scores = 0.4 * distance_scores + 0.25 * load_balance_scores + 0.35 * time_window_scores

    # Penalty for infeasible edges based on load constraints with adaptive penalty factor
    infeasible_mask = current_load.unsqueeze(1) < delivery_node_demands
    heuristic_scores[infeasible_mask] = -3.2

    # Exploration enhancement by injecting weighted Gaussian noise
    exploration_noise = 5.0 * torch.exp(-0.007 * current_time.max())
    heuristic_scores += exploration_noise * torch.randn_like(heuristic_scores)

    return heuristic_scores

7:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows: torch.Tensor, current_time: torch.Tensor) -> torch.Tensor:
    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Distance-based scoring with adaptive temperature and noise injection refinement
    temperature = 0.2 + 0.03 * torch.sigmoid(0.002 * current_time.max())
    distance_scores = torch.softmax(-current_distance_matrix / temperature, dim=1) + 0.15 * torch.randn_like(current_distance_matrix)

    # Load balance penalty with dynamic scaling and refined imbalance factor
    mean_demand = delivery_node_demands[1:].mean()
    load_balance_factor = current_load.unsqueeze(1) / torch.clamp(delivery_node_demands, min=0.1, max=mean_demand * 1.5)
    load_balance_scores = torch.where(load_balance_factor < 1.0, -3.3 * load_balance_factor ** 2.2, 0.6 * torch.abs(1.0 - load_balance_factor)) + 0.35 * torch.randn_like(current_distance_matrix)

    # Time window feasibility scoring with adjusted weights and dynamic waiting time computation
    earliest_arrival = current_time.unsqueeze(1) + current_distance_matrix
    lateness = torch.clamp(earliest_arrival - time_windows[:, 1].unsqueeze(0), max=0)
    waiting_time = torch.clamp(time_windows[:, 0].unsqueeze(0) + 3.5 - earliest_arrival, max=0)  # Dynamic waiting time impact
    time_window_scores = torch.exp(-lateness.abs() * 3.0) * torch.exp(-waiting_time * 2.5) + 0.45 * torch.randn_like(current_distance_matrix)

    # Combined scores with adjusted coefficients
    combined_scores = 0.4 * distance_scores + 0.25 * load_balance_scores + 0.35 * time_window_scores

    # Penalty for infeasible edges based on load constraints with adaptive penalty factor
    infeasible_mask = current_load.unsqueeze(1) < delivery_node_demands
    heuristic_scores[infeasible_mask] = -4.0

    # Exploration enhancement by injecting weighted Gaussian noise
    exploration_noise = 5.0 * torch.exp(-0.007 * current_time.max())
    heuristic_scores += exploration_noise * torch.randn_like(heuristic_scores)

    return heuristic_scores

8:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows:torch.Tensor, current_time:torch.Tensor) -> torch.Tensor:
    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Distance-based scoring with dynamic scaling and power transformation
    distance_scores = -0.8 * torch.pow(current_distance_matrix, 1.6) + 0.4 * torch.randn_like(current_distance_matrix)

    # Load balance penalty with exponential decay weighting and load ratio adjustment
    load_ratio = current_load.unsqueeze(1) / torch.clamp(delivery_node_demands, min=0.1)
    load_balance_scores = -1.5 * torch.exp(-load_ratio * 1.8) + 0.3 * torch.randn_like(current_distance_matrix)

    # Time window feasibility scoring with time window violation penalty
    arrival_time = current_time.unsqueeze(1) + current_distance_matrix
    tardiness = torch.clamp(arrival_time - time_windows[:, 1].unsqueeze(0), max=0)
    waiting_time = torch.clamp(time_windows[:, 0].unsqueeze(0) + 2.5 - arrival_time, max=0)
    time_window_scores = -1.4 * tardiness - 0.6 * waiting_time + 0.5 * torch.randn_like(current_distance_matrix)

    # Combined scores with customized weights
    combined_scores = 0.5 * distance_scores + 0.3 * load_balance_scores + 0.2 * time_window_scores

    # Penalty for load exceedance and infeasible edges
    load_exceedance_mask = current_load.unsqueeze(1) + delivery_node_demands > 1.5
    heuristic_scores[load_exceedance_mask] = -4.5

    # Exploration enhancement with adaptive noise
    exploration_noise = 5.2 * torch.exp(-0.007 * current_time.max())
    heuristic_scores += exploration_noise * torch.randn_like(heuristic_scores)

    return heuristic_scores

9:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows:torch.Tensor, current_time:torch.Tensor) -> torch.Tensor:

    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Distance-based scoring with further refined temperature scaling and sigmoid transformation
    temperature = 0.2 + torch.sigmoid(0.006 * current_time.max())  # Refined temperature scaling
    distance_scores = torch.sigmoid(-current_distance_matrix / (temperature ** 1.4)) + 0.2 * torch.randn_like(current_distance_matrix)

    # Load balance penalty with optimized imbalance factor and penalization strategy
    mean_demand = delivery_node_demands[1:].mean()
    load_balance_factor = torch.minimum(current_load.unsqueeze(1) / (delivery_node_demands + 1e-5), torch.tensor(1.2))  # Avoid division by zero
    load_balance_scores = -2.8 * (load_balance_factor - 1) ** 2 + 0.4 * torch.randn_like(current_distance_matrix)

    # Time windows scoring with fine-tuned weighting and enhanced waiting time calculation
    latest_departure = time_windows[:, 1].unsqueeze(0) - torch.maximum(current_distance_matrix, torch.tensor(0.2))  # Adjusted latest departure time
    earliness = torch.maximum(time_windows[:, 0].unsqueeze(0) - (current_time.unsqueeze(1) + current_distance_matrix), torch.tensor(0))  # Considering early arrivals
    time_window_scores = torch.exp(-earliness.abs() * 3.0) * torch.exp(-(latest_departure - time_windows[:, 1].unsqueeze(0)) / 1.8) + 0.25 * torch.randn_like(current_distance_matrix)

    # Combined heuristic scores with further optimized coefficients
    combined_scores = 0.45 * distance_scores + 0.4 * load_balance_scores + 0.15 * time_window_scores

    # Penalty for infeasible edges based on capacity constraints with adaptive penalty scaling
    infeasible_mask = current_load.unsqueeze(1) < delivery_node_demands
    heuristic_scores[infeasible_mask] = -4.5

    # Exploration enhancement through volatility injection with improved noise weights
    exploration_noise = 5.0 * torch.exp(-0.006 * current_time.max())  # Enhanced environmental influence factor for noise adaptation
    heuristic_scores += exploration_noise * torch.randn_like(heuristic_scores)

    return heuristic_scores

10:def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, time_windows:torch.Tensor, current_time:torch.Tensor) -> torch.Tensor:
    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Distance-based scoring with temperature adaptation and noise injection
    temperature = 0.15 + torch.sigmoid(0.004 * current_time.max())
    distance_scores = torch.softmax(-current_distance_matrix / temperature, dim=1) + 0.2 * torch.randn_like(current_distance_matrix)

    # Load balance penalty with dynamic scaling and refined imbalance factor
    mean_demand = delivery_node_demands[1:].mean()
    load_balance_factor = current_load.unsqueeze(1) / torch.clamp(delivery_node_demands, min=0.1, max=mean_demand*1.4)
    load_balance_scores = torch.where(load_balance_factor < 1.0,
                                      -3.0 * load_balance_factor ** 2.1,
                                      0.5 * torch.abs(1.0 - load_balance_factor)) + 0.3*torch.randn_like(current_distance_matrix)

    # Time window feasibility scoring with adjusted weights and dynamic waiting time computation
    earliest_arrival = current_time.unsqueeze(1) + current_distance_matrix
    lateness = torch.clamp(earliest_arrival - time_windows[:, 1].unsqueeze(0), max=0)
    waiting_time = torch.clamp(time_windows[:, 0].unsqueeze(0) + 3.0 - earliest_arrival, max=0)  # Dynamic waiting time impact
    time_window_scores = torch.exp(-lateness.abs() * 2.8) * torch.exp(-waiting_time * 2.1) + 0.4*torch.randn_like(current_distance_matrix)

    # Combined scores with adjusted coefficients
    combined_scores = 0.45 * distance_scores + 0.3 * load_balance_scores + 0.25 * time_window_scores

    # Penalty for infeasible edges based on load constraints with adaptive penalty factor
    infeasible_mask = current_load.unsqueeze(1) < delivery_node_demands
    heuristic_scores[infeasible_mask] = -3.5

    # Exploration enhancement by injecting weighted Gaussian noise
    exploration_noise = 4.8 * torch.exp(-0.006 * current_time.max())
    heuristic_scores += exploration_noise * torch.randn_like(heuristic_scores)

    return heuristic_scores