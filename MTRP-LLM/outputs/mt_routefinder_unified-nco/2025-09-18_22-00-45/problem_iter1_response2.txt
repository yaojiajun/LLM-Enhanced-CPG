```python
import torch
import torch.nn.functional as F
import torch.distributions as tdist

def heuristics_v2(current_distance_matrix, delivery_node_demands, current_load, delivery_node_demands_open, current_load_open, time_windows, arrival_times, pickup_node_demands, current_length):
    # Normalize input variables
    normalized_distances = F.normalize(current_distance_matrix, p=2, dim=1)
    normalized_load = F.normalize(current_load.unsqueeze(2), p=2, dim=1)
    normalized_open_load = F.normalize(current_load_open.unsqueeze(2), p=2, dim=1)
    normalized_pickup_demands = F.normalize(pickup_node_demands.unsqueeze(0), p=2, dim=1)
    normalized_current_length = F.normalize(current_length.unsqueeze(2), p=2, dim=1)

    # Randomly assign heuristic scores using probability distributions
    num_nodes = current_distance_matrix.size(1)
    heuristic_scores = torch.zeros_like(current_distance_matrix)
    dist_prior = tdist.Categorical(probs=torch.exp(torch.rand(current_distance_matrix.size())))
    load_prior = tdist.Categorical(probs=torch.exp(torch.rand(current_load.size())))
    open_load_prior = tdist.Categorical(probs=torch.exp(torch.rand(current_load_open.size())))
    pickup_prior = tdist.Categorical(probs=torch.exp(torch.rand(pickup_node_demands.size())))
    length_prior = tdist.Categorical(probs=torch.exp(torch.rand(current_length.size())))

    for i in range(normalized_distances.size(0)):
        heuristic_scores[i] += dist_prior.sample().reshape(1, num_nodes)
        heuristic_scores[i] += load_prior.sample().reshape(1, num_nodes)
        heuristic_scores[i] += open_load_prior.sample().reshape(1, num_nodes) 
        heuristic_scores[i] += pickup_prior.sample().reshape(1, num_nodes)
        heuristic_scores[i] += length_prior.sample().reshape(1, num_nodes)

    return heuristic_scores

```
