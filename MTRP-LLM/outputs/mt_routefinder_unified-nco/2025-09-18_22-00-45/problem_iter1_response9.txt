```python
import torch
import torch.nn.functional as F

def heuristics_v2(current_distance_matrix, delivery_node_demands, current_load, delivery_node_demands_open, current_load_open, time_windows, arrival_times, pickup_node_demands, current_length):
    # Calculate heuristic scores based on different criteria
    load_score = torch.div(current_load_open, delivery_node_demands_open)  # Higher scores imply more remaining load
    time_window_score = torch.where((time_windows[:, 0] < arrival_times) & (arrival_times < time_windows[:, 1]), torch.tensor(1.0), torch.tensor(0.0))  # Score based on time window feasibility
    pickup_demand_score = F.leaky_relu(torch.div(current_load, pickup_node_demands), negative_slope=0.1)  # Score based on capacity to collect pickups
    length_constraint_score = torch.div(current_remaining_length, current_length)  # Score based on length constraints

    heuristic_scores = load_score + time_window_score + pickup_demand_score + length_constraint_score

    return heuristic_scores

```
