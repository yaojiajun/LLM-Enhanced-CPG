```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # cvrp_scores_v2
    normalized_distance_scores_v2 = -current_distance_matrix / torch.max(current_distance_matrix) + torch.randn_like(
        current_distance_matrix) * 0.7

    demand_scores_v2 = (delivery_node_demands.unsqueeze(1) - current_load) * 0.5 + torch.randn_like(current_distance_matrix) * 0.9

    enhanced_noise_v2 = torch.randn_like(current_distance_matrix) * 1.5

    cvrp_scores_v2 = normalized_distance_scores_v2 + demand_scores_v2 + enhanced_noise_v2


    vrptw_scores_v2
    earliest_times = time_windows[:, 0].unsqueeze(1)
    latest_times = time_windows[:, 1].unsqueeze(1)

    waiting_times_v2 = torch.clamp(earliest_times - arrival_times, min=0)

    late_arrivals_v2 = torch.clamp(arrival_times - latest_times, min=0)

    criticality_weights_v2 = torch.where(late_arrivals_v2 > 0, 2.0, 0.2)

    time_compensation_v2 = criticality_weights_v2 * (waiting_times_v2 + late_arrivals_v2)

    vrptw_scores_v2 = time_compensation_v2


    vrpb_scores_v2
    vehicle_capacity = 100.0

    non_zero_demands_v2 = pickup_node_demands > 0

    used_capacity_v2 = torch.sum(pickup_node_demands * non_zero_demands_v2.float())

    remaining_capacity_v2 = vehicle_capacity - used_capacity_v2

    vrpb_compensation_v2 = torch.where(
        non_zero_demands_v2,
        (remaining_capacity_v2 - pickup_node_demands) * non_zero_demands_v2.float(),
        torch.zeros_like(cvrp_scores_v2)
    )

    vrpb_compensation_v2 = torch.clamp(vrpb_compensation_v2, min=0)

    vrpb_scores_v2 = vrpb_compensation_v2

    
    vrpl_scores_v2
    pomo_size, n_plus_1 = cvrp_scores_v2.shape

    feasible_mask_v2 = (current_length.unsqueeze(1) > 0)  

    vrpl_compensation_v2 = torch.where(feasible_mask_v2, 1 / (current_length.unsqueeze(1) + 1e-6),
                                    torch.zeros_like(cvrp_scores_v2))  

    vrpl_scores_v2 = vrpl_compensation_v2


    ovrp_scores_v2
    pomo_size, N = cvrp_scores_v2.shape

    torch.manual_seed(42)

    noise_scale_factors_1_v2 = (0.5 + 0.5 * torch.rand((pomo_size, 1))) * (1 + 0.5 * torch.randn((pomo_size, N)).clamp(-1, 1)) * (0.8 + 0.2 * torch.rand((pomo_size, N)))
    noise_scale_factors_2_v2 = (0.6 + 0.4 * torch.rand((pomo_size, 1))) * (1 + 0.6 * torch.randn((pomo_size, N)).clamp(-1, 1)) * (0.9 + 0.1 * torch.rand((pomo_size, N)))
    noise_scale_factors_3_v2 = (0.4 + 0.6 * torch.rand((pomo_size, 1))) * (1 + 0.4 * torch.randn((pomo_size, N)).clamp(-1, 1)) * (0.7 + 0.3 * torch.rand((pomo_size, N)))

    demand_sensitivity_v2 = (delivery_node_demands_open / current_load_open).unsqueeze(2) * \
                         (1.2 * torch.rand((pomo_size, N))).clamp(0.75, 2.0)

    global_variation_v2 = (0.525 + 0.475 * torch.rand((pomo_size, 1))) * \
                       (current_load_open.unsqueeze(2) * (torch.randn((pomo_size, N)).clamp(-1, 1)))

    adaptive_scale_factor_v2 = (0.85 + 0.15 * torch.rand((pomo_size, 1)))

    ovrp_compensation_v2 = (noise_scale_factors_1_v2 + noise_scale_factors_2_v2 + noise_scale_factors_3_v2 + global_variation_v2) * \
                        (demand_sensitivity_v2 * adaptive_scale_factor_v2)

    ovrp_scores_v2 = ovrp_compensation_v2
        
    overall_scores_v2 = cvrp_scores_v2 + vrptw_scores_v2 + vrpb_scores_v2 + vrpl_scores_v2 + ovrp_scores_v2

    return overall_scores_v2
```
