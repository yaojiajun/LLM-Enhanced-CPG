```python
import torch
import torch.nn.functional as F
import torch.randperm
import torch.argsort

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Calculate load feasibility based on delivery and pickup demands
    delivery_load_feasibility = delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1)
    pickup_load_feasibility = pickup_node_demands.unsqueeze(0) <= current_load_open.unsqueeze(1)
    
    # Calculate time window feasibility
    earliest_time_window = time_windows[:, 0].unsqueeze(0)
    latest_time_window = time_windows[:, 1].unsqueeze(0)
    arrival_t_feasibility = arrival_times + current_distance_matrix <= latest_time_window
    time_window_feasibility = (arrival_times >= earliest_time_window) & arrival_t_feasibility
    
    # Calculate length constraints feasibility
    valid_length = current_length.unsqueeze(1) >= current_distance_matrix
    
    # Combine all feasibility conditions
    cumulative_feasibility_score = (delivery_load_feasibility & time_window_feasibility & pickup_load_feasibility & valid_length).to(torch.float32)
    
    # Introduce randomness to prevent premature convergence
    cumulative_feasibility_score += torch.randperm(current_distance_matrix.size(1))[1:]
    
    # Calculate heuristic score as inverted distance adjusted by feasibility
    heuristic_score = -current_distance_matrix * cumulative_feasibility_score
    
    return heuristic_score
```
