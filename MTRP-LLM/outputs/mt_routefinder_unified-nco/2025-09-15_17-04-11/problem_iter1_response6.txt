```python
import torch
import torch.nn.functional as F

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Compute normalized indicators based on distance, load, time windows, arrival times, and length constraints
    distance_indicator = 1 / (current_distance_matrix + 1e-6)  # Added epsilon to avoid division by zero
    load_indicator = current_load / (delivery_node_demands + 1e-6)
    load_open_indicator = current_load_open / (delivery_node_demands_open + 1e-6)
    time_window_indicator = torch.sigmoid((arrival_times - time_windows[:, 1].unsqueeze(0)) / (time_windows[:, 1] - time_windows[:, 0]).unsqueeze(0)).clamp(0, 1)
    length_indicator = current_length.unsqueeze(1) / (current_distance_matrix + 1e-6)
    
    # Combine indicators with different weights and introduce randomness
    heuristic_score = (0.3 * distance_indicator + 0.2 * load_indicator + 0.1 * load_open_indicator + 0.2 * time_window_indicator + 0.2 * length_indicator) * torch.rand(current_distance_matrix.shape)
    
    return F.normalize(heuristic_score, p=2, dim=-1)

```  
