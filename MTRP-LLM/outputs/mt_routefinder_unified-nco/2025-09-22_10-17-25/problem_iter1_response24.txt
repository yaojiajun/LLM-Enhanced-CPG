```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Updated heuristics_v2 function
    # Modify the computation related to 'current_distance_matrix', 'delivery_node_demands', and 'current_load' only

    # Compute an inverse distance score with scaled randomness for exploration
    inv_distance_scores = 1.0 / (current_distance_matrix + 1e-6) + torch.randn_like(current_distance_matrix) * 0.5

    # Compute demand fulfillment score with a focus on missed deliveries
    delivery_score = torch.max(delivery_node_demands - current_load, torch.zeros_like(current_load)) + torch.randn_like(current_load) * 0.5

    # Introduce a penalty for exceeding capacity to improve load balancing
    overload_penalty = torch.max(current_load - delivery_node_demands, torch.zeros_like(current_load))

    # Calculate total score incorporating modified distance, delivery, and overload penalties
    total_score = inv_distance_scores - delivery_score - overload_penalty

    return total_score

```
