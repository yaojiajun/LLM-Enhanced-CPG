```python
def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # cvrp_scores_modified
    # Compute distance-based heuristic score matrix with increased emphasis on shorter distances
    distance_heuristic = -current_distance_matrix / torch.min(current_distance_matrix + 1e-8)
    
    # Scale delivery demands and remaining load to be capped at 1 for better integration
    scaled_delivery_demands = delivery_node_demands / torch.max(delivery_node_demands + 1e-8)
    scaled_remaining_load = current_load / torch.max(current_load + 1e-8)
    
    # Introduce adaptability parameter for exploring different demand-load tradeoffs dynamically
    adaptability = 0.7 + 0.3 * torch.rand_like(current_distance_matrix)
    
    # Combine distance heuristic with evolved delivery-demand-load metric for cvrp_scores_modified
    cvrp_scores_modified = distance_heuristic + 0.8 * scaled_delivery_demands.unsqueeze(0) * scaled_remaining_load.unsqueeze(1) * adaptability

    # Keep the subsequent sections, e.g., vrptw_scores, vrpb_scores, vrpl_scores, and so on identical to heuristics_v1
    # ...
    # ...
    
    return cvrp_scores_modified
```  
