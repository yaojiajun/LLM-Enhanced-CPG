```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Custom modifications for heuristics based on current_distance_matrix, delivery_node_demands, and current_load
    # Initialize heuristics matrix
    pomo_size, N = current_distance_matrix.shape
    updated_scores = torch.zeros((pomo_size, N))

    # Custom distance-based heuristic score calculation
    distance_heuristic = torch.exp(-current_distance_matrix)  # Utilize exponential decay for distance scoring
    # Normalize distance heuristic scores
    normalized_distance_heuristic = distance_heuristic / torch.max(distance_heuristic)

    # Custom delivery node demands based heuristic score calculation
    delivery_score = delivery_node_demands.unsqueeze(0) / (current_load.unsqueeze(1) + 1e-8)  # Introduce reciprocal relationship
    delivery_score = torch.pow(delivery_score, 0.8)  # Adjust sensitivity with power transformation

    # Custom current load capacity based compensation
    capacity_compensation = 1 / (current_load + 1e-8)  # Reciprocal relationship for load capacity
    capacity_compensation = 1 / (capacity_compensation + torch.randn_like(capacity_compensation) * 0.6)  # Add randomness for diversity
    
    # Combine the customized score components into the total score matrix
    updated_scores = normalized_distance_heuristic + delivery_score - capacity_compensation

    return updated_scores

```  
