```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Assume num_vehicles and num_nodes are extracted from input shapes
    pomo_size, num_nodes = current_distance_matrix.shape
    
    # Initialize heuristic scores
    heuristic_scores = torch.zeros_like(current_distance_matrix)
    
    # Calculate feasible deliveries based on demand and load constraints
    feasible_deliveries = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)) & \
                          (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0))
    
    # Time window feasibility
    current_time = arrival_times
    time_window_feasibility = (current_time.unsqueeze(1) <= time_windows[:, 1]) & \
                               (current_time.unsqueeze(1) >= time_windows[:, 0])
    
    # Combined feasibility
    combined_feasibility = feasible_deliveries & time_window_feasibility
    
    # Cost-based scoring (lower distances are better)
    distance_scores = -current_distance_matrix * combined_feasibility.float()
    
    # Add randomness to enhance exploration in the heuristic search
    random_component = torch.rand_like(current_distance_matrix) * 0.1  # Small random noise
    heuristic_scores = distance_scores + random_component
    
    # Ensure negative scores where constraints are violated
    heuristic_scores[~combined_feasibility] -= 1000  # Strong penalty for infeasible edges
    
    return heuristic_scores
```
