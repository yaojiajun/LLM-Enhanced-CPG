```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Heuristic score matrix initialized to zero
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Capacity constraints for deliveries
    delivery_capacity = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    delivery_capacity_open = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()
    
    # Time window feasibility
    time_window_feasibility = ((arrival_times.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0)).float() * 
                                (arrival_times.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0)).float())
    
    # Duration feasibility
    duration_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix).float()

    # Calculate heuristic scores based on feasibility
    heuristic_scores += delivery_capacity * time_window_feasibility * duration_feasibility

    # Normalize the scores by distances and add noise for randomness
    norm_distance_matrix = current_distance_matrix / current_distance_matrix.max(dim=1, keepdim=True).values
    noisy_scores = heuristic_scores - norm_distance_matrix * 0.5 + (torch.rand_like(heuristic_scores) * 0.1)

    # Apply additional randomness to enhance exploration
    randomness_factor = torch.rand_like(noisy_scores) * 0.1
    heuristic_scores = noisy_scores + randomness_factor

    return heuristic_scores
```
