```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Initialize the heuristic score matrix
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Calculate feasibility for deliveries
    feasible_deliveries = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0))  # shape: (pomo_size, N+1)
    time_constraints = (arrival_times < time_windows[:, 1].unsqueeze(0)) & (arrival_times >= time_windows[:, 0].unsqueeze(0))  # shape: (pomo_size, N+1)
    length_constraints = (current_length.unsqueeze(1) >= current_distance_matrix)  # shape: (pomo_size, N+1)

    # Combined feasibility
    combined_feasibility = feasible_deliveries & time_constraints & length_constraints
    
    # Proximity scores based on distance
    proximity_scores = -current_distance_matrix * combined_feasibility.float()  # only consider feasible edges
    
    # Calculate pickup feasibility
    feasible_pickups = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0))
    
    # Apply randomness for diversification and adaptability
    random_scores = torch.rand_like(current_distance_matrix) * 0.1  # Introduce randomness to scores
    heuristic_scores = proximity_scores + random_scores * combined_feasibility.float()  # combine scores with randomness

    # Incorporate scoring for pickups
    heuristic_scores += (feasible_pickups.float() * 0.5)  # penalize infeasibility for pickups

    # Normalize scores based on proximity and feasibility
    heuristic_scores = torch.where(combined_feasibility, heuristic_scores, torch.tensor(float('-inf')).to(heuristic_scores.device))  # Set undesirable scores to -inf

    return heuristic_scores
```
