```python
import torch
import torch.nn.functional as F

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Calculate the ratio of remaining load to demand as a measure of load feasibility
    load_ratio = current_load.unsqueeze(1) / (delivery_node_demands + 1e-6)  # Adding a small value for numerical stability
    load_score = torch.log(load_ratio)

    # Calculate the waiting time penalty based on time window feasibility
    wait_time = F.relu(arrival_times - time_windows[:, 1].unsqueeze(0))  # Calculate the delay time for each node
    wait_score = -wait_time

    # Evaluate the pickup capacity feasibility
    pickup_ratio = current_load_open.unsqueeze(1) / (pickup_node_demands + 1e-6)  # Adding a small value for numerical stability
    pickup_score = torch.log(pickup_ratio)

    # Penalize edges that violate route duration constraints
    violation_length = current_distance_matrix > current_length.unsqueeze(1)  # Flagging routes exceeding length limits
    length_penalty = torch.where(violation_length, -current_distance_matrix, torch.zeros_like(current_distance_matrix))

    # Introduce randomness for exploration
    random_scores = torch.rand_like(current_distance_matrix) * 0.1

    # Combine all indicators by multiplying with different weights
    heuristic_scores = 1 * load_score + 0.5 * wait_score - 1 * pickup_score + length_penalty - 0.3 * random_scores
    
    return heuristic_scores

```
