```python
import torch
import torch.nn.functional as F

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Calculate load feasibility indicators for delivery and pickup
    load_feasibility_delivery = (delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1))
    load_feasibility_pickup = (pickup_node_demands.unsqueeze(0) <= current_load.unsqueeze(1))
    load_feasibility = load_feasibility_delivery.float() * load_feasibility_pickup.float()

    # Calculate time window feasibility indicators
    earliest_times = time_windows[:, 0].unsqueeze(0)
    latest_times = time_windows[:, 1].unsqueeze(0)
    time_window_feasibility = ((earliest_times <= arrival_times) & (latest_times >= arrival_times)).float()

    # Calculate length feasibility indicators
    length_feasibility = (current_distance_matrix <= current_length.unsqueeze(1)).float()

    # Combine various feasibility indicators
    feasibility_score = load_feasibility * time_window_feasibility * length_feasibility

    # Add enhanced randomness to the feasibility score matrix
    feasibility_score_with_noise = feasibility_score + torch.rand(feasibility_score.size())  # Add noise for enhanced randomness

    # Compute heuristic score matrix
    heuristic_score = F.leaky_relu(feasibility_score_with_noise, negative_slope=0.1)

    return heuristic_score
```
