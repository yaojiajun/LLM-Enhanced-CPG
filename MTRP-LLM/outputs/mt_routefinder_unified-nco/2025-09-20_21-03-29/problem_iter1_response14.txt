```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Calculate modified heuristic scores based on the given inputs (current_distance_matrix, delivery_node_demands, current_load)
    
    # Radically transforming the way distances, demands, and loads impact edge scores
    distance_heuristic = calculate_distance_heuristic(current_distance_matrix)
    
    delivery_score = calculate_delivery_score(delivery_node_demands, current_load)
    
    pickup_score = calculate_pickup_score(pickup_node_demands, current_load_open)
    
    total_score = distance_heuristic + delivery_score + pickup_score
    
    return total_score
    
def calculate_distance_heuristic(current_distance_matrix):
    # Custom distance heuristic calculation
    distance_penalty = torch.min(current_distance_matrix, dim=1)[0]  # Penalty based on the minimum distance to other nodes
    
    return 1 / (distance_penalty + 1e-8)  # Inverse of the distance penalty with numerical stability
    
def calculate_delivery_score(delivery_node_demands, current_load):
    # Custom delivery score calculation
    demand_ratio = delivery_node_demands / (current_load + 1e-8)  # Avoid zero division with epsilon
    
    return demand_ratio + torch.randn_like(demand_ratio)  # Add random noise for exploration
    
def calculate_pickup_score(pickup_node_demands, current_load_open):
    # Custom pickup score calculation
    pickup_ratio = pickup_node_demands / (current_load_open + 1e-8)  
    
    return -(pickup_ratio)  # Negative score for pickups impacting the open route load

```
