```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Initialize heuristic scores
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Calculate feasibility of visiting each node based on capacity, load, and remaining length
    feasible_delivery = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)) & (current_length.unsqueeze(1) >= current_distance_matrix)
    feasible_pickup = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0)) & (current_length.unsqueeze(1) >= current_distance_matrix)

    # Time window evaluations
    time_window_met = (arrival_times <= time_windows[:, 1].unsqueeze(0)) & (arrival_times >= time_windows[:, 0].unsqueeze(0))
    
    # Combine feasibility conditions
    combined_feasibility = feasible_delivery & time_window_met & feasible_pickup

    # Compute additional score components
    distance_scores = torch.where(combined_feasibility, -current_distance_matrix, torch.tensor(float('inf')).to(current_distance_matrix.device))
    
    # Introduce randomness and adapt it based on constraints severity
    constraint_severity = (delivery_node_demands / current_load.unsqueeze(1)).clamp(0, 1) + (pickup_node_demands / current_load_open.unsqueeze(1)).clamp(0, 1)
    random_scores = torch.rand_like(current_distance_matrix) * (1 - constraint_severity)

    # Aggregate scores
    heuristic_scores = distance_scores + random_scores

    # Adjust scores for overall path feasibility
    heuristic_scores[~combined_feasibility] = float('-inf')  # Mark infeasible routes with negative infinity

    return heuristic_scores
```
