```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Basic constants
    vehicle_count, node_count = current_distance_matrix.shape
    heuristic_scores = torch.zeros_like(current_distance_matrix)
    
    # Explore potential scores for visiting nodes
    # Consider delivery demands, current load, and distance
    feasible_delivery = (delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1)) & \
                        (current_distance_matrix < float('inf'))
    
    delivery_scores = torch.where(feasible_delivery, 
                             -current_distance_matrix + (delivery_node_demands.unsqueeze(0) / (current_load.unsqueeze(1) + 1e-6)), 
                             torch.tensor(float('-inf')).to(current_distance_matrix.device))
    
    # Explore potential scores for open routes
    feasible_open = (delivery_node_demands_open.unsqueeze(0) <= current_load_open.unsqueeze(1)) & \
                    (current_distance_matrix < float('inf'))
    
    open_scores = torch.where(feasible_open, 
                               -current_distance_matrix + (delivery_node_demands_open.unsqueeze(0) / (current_load_open.unsqueeze(1) + 1e-6)), 
                               torch.tensor(float('-inf')).to(current_distance_matrix.device))

    # Combine delivery and open route scores, introducing randomization
    combined_scores = delivery_scores + open_scores + (torch.rand_like(current_distance_matrix) * 0.1)
    
    # Incorporate time window constraints
    for i in range(vehicle_count):
        # Calculate waiting times based on time windows
        arrival_window = (arrival_times[i].unsqueeze(0) < time_windows[:, 1]) & \
                         (arrival_times[i].unsqueeze(0) > time_windows[:, 0])
        combined_scores[i, ~arrival_window] = float('-inf')
    
    # Assess total route length constraints
    length_constraints = (current_length.unsqueeze(1) - current_distance_matrix.sum(dim=1, keepdim=True) >= 0)
    combined_scores[~length_constraints] = float('-inf')

    # Final heuristic scores based on combined metrics
    heuristic_scores = combined_scores

    return heuristic_scores
```
