```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Calculate available capacity and time constraints
    available_capacity = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    available_capacity_open = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()
    time_constraints = (arrival_times.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0)).float() * \
                       (arrival_times.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0)).float()
    duration_constraints = (current_length.unsqueeze(1) >= current_distance_matrix).float()

    # Combine constraints for valid edges
    valid_edges = available_capacity * available_capacity_open * time_constraints * duration_constraints

    # Calculate heuristic scores based on distance and validity
    heuristic_scores = valid_edges * (1 / (current_distance_matrix + 1e-6))

    # Introduce randomness to avoid local optima
    random_scores = torch.rand_like(heuristic_scores) * valid_edges  # only allow randomness where edges are valid
    random_scale = torch.sum(valid_edges, dim=1, keepdim=True)  # adaptive scaling based on valid edges available
    random_scores /= (random_scale + 1e-6)  # Normalize

    # Final heuristic scores combining deterministic and random components
    final_scores = heuristic_scores + (0.5 * random_scores)  # Balance between two components

    return final_scores
```
