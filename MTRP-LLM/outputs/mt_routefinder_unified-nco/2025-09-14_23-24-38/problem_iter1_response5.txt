```python
import torch
import torch.nn.functional as F
import torch.distributions as tdist

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Compute heuristic indicators based on various constraints and objective functions
    capacity_ratio = current_load / (delivery_node_demands + 1)  # Adding 1 to avoid division by zero
    time_window_score = torch.abs(arrival_times[:, 1:] - time_windows[:, 1])  # Difference between arrival times and latest service time
    length_remaining_ratio = current_length / (current_distance_matrix + 0.01)  # Ratio of remaining length budget to distance

    # Introduce randomness to promote diversity in edge selection
    random_noise = tdist.Uniform(-1, 1).sample(current_distance_matrix.size())

    # Combine heuristic indicators with random noise to guide edge selection
    heuristic_scores = capacity_ratio + time_window_score + length_remaining_ratio + random_noise

    return heuristic_scores

```  
