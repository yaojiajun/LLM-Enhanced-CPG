```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Initialize heuristic scores with a random matrix
    heuristic_scores = torch.rand_like(current_distance_matrix, dtype=torch.float32)

    # Define constraints
    vehicle_capacity = current_load.unsqueeze(-1) >= delivery_node_demands.unsqueeze(0)
    vehicle_capacity_open = current_load_open.unsqueeze(-1) >= delivery_node_demands_open.unsqueeze(0)
    time_constraints = (arrival_times.unsqueeze(-1) <= time_windows[:, 1]) & (arrival_times.unsqueeze(-1) >= time_windows[:, 0])
    length_constraints = current_length.unsqueeze(-1) >= current_distance_matrix

    # Combine feasibility checks
    feasible_moves = vehicle_capacity & vehicle_capacity_open & time_constraints & length_constraints

    # Score adjustments based on feasibility
    heuristic_scores[~feasible_moves] = -1e6  # Penalize infeasible moves

    # Enhance scoring based on distance and remaining capacity for potential deliveries
    scores_adjustment = (1.0 / (current_distance_matrix + 1e-5)) * (current_load.unsqueeze(-1) / delivery_node_demands.unsqueeze(0).clamp(min=1))
    heuristic_scores += scores_adjustment * feasible_moves.float()

    # Introduce randomness based on a fixed scaling parameter for exploration
    scaling_factor = 0.1 * torch.max(heuristic_scores, dim=1, keepdim=True).values
    random_noise = torch.rand_like(heuristic_scores) * scaling_factor
    heuristic_scores += random_noise

    # Ensure scores are normalized and bounded
    heuristic_scores = torch.clamp(heuristic_scores, min=-1e6, max=torch.max(heuristic_scores))

    return heuristic_scores
```
