```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize the heuristic score matrix
    pomo_size, N_plus1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros((pomo_size, N_plus1), device=current_distance_matrix.device)
    
    # Compute feasible selection mask for delivery nodes based on current_load
    feasible_delivery = (delivery_node_demands.view(1, -1) <= current_load.view(-1, 1)) & (delivery_node_demands_open.view(1, -1) <= current_load_open.view(-1, 1))
    
    # Check time windows feasibility
    time_within_bounds = (arrival_times <= time_windows[:, 1].view(1, -1)) & (arrival_times >= time_windows[:, 0].view(1, -1))
    
    # Determine length feasibility
    length_constraint = current_length.view(-1, 1) > current_distance_matrix
    
    # Combine constraints
    feasibility_matrix = feasible_delivery & time_within_bounds & length_constraint
    
    # Score positive for feasible routes
    heuristic_scores[feasibility_matrix] = -current_distance_matrix[feasibility_matrix]  # Lower distances should be preferred
    
    # Calculate undesired scores for infeasible routes
    heuristic_scores[~feasibility_matrix] = torch.tensor(float('-inf'), device=heuristic_scores.device)
    
    # Introduce randomness to avoid local optima
    random_exploration_weights = torch.rand((pomo_size, N_plus1), device=current_distance_matrix.device) * 0.1  # 10% randomness
    heuristic_scores += random_exploration_weights
    
    return heuristic_scores
```
