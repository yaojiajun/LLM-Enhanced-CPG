```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Constraints: Vehicle's current capacity compared to node demands
    can_deliver = (current_load.unsqueeze(1) >= delivery_node_demands[:-1].unsqueeze(0)).float()  # excluding depot
    can_open_pickup = (current_load_open.unsqueeze(1) >= pickup_node_demands[:-1].unsqueeze(0)).float()

    # Time window feasibility: The arrival time must fit with allowed service intervals
    within_time_windows = ((arrival_times + current_distance_matrix >= time_windows[:, 0].unsqueeze(0)) &
                            (arrival_times + current_distance_matrix <= time_windows[:, 1].unsqueeze(0))).float()

    # Length constraint: Route budget should cover current route length plus distance to new visit
    within_length_budget = (current_length.unsqueeze(1) >= current_distance_matrix).float()
    
    # Calculate heuristic base using the negative distance for preference
    distance_heuristic = -current_distance_matrix

    # Combining constraints with distance: Only favorable conditions contribute positively
    heuristic_scores = (distance_heuristic * can_deliver * within_time_windows * within_length_budget)
    
    # Introduce randomness to stimulate exploration
    randomness_factor = torch.rand_like(heuristic_scores) * 0.1  # small randomness influence
    heuristic_scores += randomness_factor

    return heuristic_scores
```
