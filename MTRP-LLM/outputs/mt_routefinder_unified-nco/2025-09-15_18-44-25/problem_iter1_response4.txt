```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Constants
    very_large_number = 1e10

    # Determine feasibility masks
    valid_delivery = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)) & \
                     (current_length.unsqueeze(1) >= current_distance_matrix)  # Check for delivery capacity
    valid_pickup = (current_load_open.unsqueeze(1) + pickup_node_demands.unsqueeze(0) <= current_load.unsqueeze(0).max()) & \
                   (current_length.unsqueeze(1) >= current_distance_matrix)  # Check for pickup capacity
   
    # Check time windows feasibility
    time_windows_open = (arrival_times.unsqueeze(1) + current_distance_matrix) >= time_windows[:, 0].unsqueeze(0)
    time_windows_close = (arrival_times.unsqueeze(1) + current_distance_matrix) <= time_windows[:, 1].unsqueeze(0)
    
    # Compute availability per edge based on constraints
    valid_edges = valid_delivery | valid_pickup
    time_window_valid = time_windows_open & time_windows_close
    feasibility_mask = valid_edges & time_window_valid
    
    # Calculate heuristic scores
    heuristic_scores = -current_distance_matrix * feasibility_mask.float()  # Inverse travel distance for valid edges
    heuristic_scores += very_large_number * (~feasibility_mask).float()  # Apply large number penalty for invalid edges

    # Enhance randomness to avoid local optima
    noise = torch.randn_like(heuristic_scores) * 0.1  # Small random noise
    heuristic_scores += noise
    
    return heuristic_scores
```
