```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize heuristic scores
    posebnoef_score = torch.zeros_like(current_distance_matrix)

    # Compute load feasibility
    service_capacity = (current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)) >= 0
    service_capacity_open = (current_load_open.unsqueeze(1) - delivery_node_demands_open.unsqueeze(0)) >= 0
    feasible_loads = service_capacity & service_capacity_open

    # Compute time window feasibility
    arrival_before_time_window = arrival_times < time_windows[:, 0].unsqueeze(0)
    arrival_within_time_window = arrival_times > time_windows[:, 1].unsqueeze(0)

    # We add waiting cost with respect to time window constraints
    waiting_time = torch.max(torch.zeros_like(current_distance_matrix), 
                             time_windows[:, 0].unsqueeze(0) - arrival_times)
    
    # Compute length constraints enforcing max lengths
    over_length = current_length.unsqueeze(1) - current_distance_matrix < 0
    
    # Penalty for exceeding duration limits
    penalty_length = over_length.float() * 1000  # Large penalty if over limits
   
    # Score indicates feasibility multiplied by inverse distance, and incorporates the aforementioned penalties 
    posebnoef_score = (feasible_loads.float() * 
                       (1.0 / (current_distance_matrix + 1e-5)) * 100 - 
                       waiting_time * 10 - 
                       penalty_length)

    # Enhance randomness to explore other solutions
    random_exploration = torch.randn_like(posebnoef_score) * 0.1
    especialmente_score += random_exploration 
    
    return posebnoef_score
```
