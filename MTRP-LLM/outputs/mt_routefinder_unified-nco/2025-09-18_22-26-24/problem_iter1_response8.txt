```python
import torch
import torch.nn.functional as F

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Normalize input data
    delivery_node_demands = F.normalize(delivery_node_demands)
    current_load = F.normalize(current_load, p=float('inf'))  # Pay more attention to load constraints
    delivery_node_demands_open = F.normalize(delivery_node_demands_open)
    current_load_open = F.normalize(current_load_open, p=float('inf'))  # Pay more attention to load constraints
    time_windows = F.normalize(time_windows)
    arrival_times = F.normalize(arrival_times)
    pickup_node_demands = F.normalize(pickup_node_demands)
    current_length = F.normalize(current_length, p=float('inf'))  # Pay more attention to route length constraints

    # Add random noise to introduce randomness
    noise = torch.rand_like(current_distance_matrix) * 0.001  # Adjust the noise amplitude as needed
    randomized_distance_matrix = current_distance_matrix + noise

    # Apply heuristics combining different considerations
    heuristic_score_matrix = randomized_distance_matrix * current_load[:, None] / (1 + delivery_node_demands[None])
    heuristic_score_matrix -= arrival_times[:, 1:] - time_windows[:, 0][None]
    heuristic_score_matrix *= (pickup_node_demands[None] + 1) / (1 + current_load_open[:, None])
    heuristic_score_matrix -= current_length[:, None] * 0.01

    return heuristic_score_matrix

```
