```python
import torch
import torch.nn.functional as F
import numpy as np

def heuristics_v2(current_distance_matrix, delivery_node_demands, current_load, delivery_node_demands_open, current_load_open, time_windows, arrival_times, pickup_node_demands, current_length):
    
    # Compute some key indicators based on the inputs
    load_indicator = current_load / current_load.mean()  # Normalized load values
    time_window_diff = time_windows[:, 1] - time_windows[:, 0]  # Time window intervals
    
    # Generate random noise for enhanced randomness
    noise = torch.rand_like(current_distance_matrix) * 0.01  # Small random noise
    
    # Create the heuristic score matrix
    heuristic_score = current_distance_matrix  # Initialize with the distance matrix
    
    # Apply some heuristic modifications based on indicators
    heuristic_score += torch.tensor(load_indicator).unsqueeze(1)  # Add load importance
    
    weighted_arival = arrival_times * 0.5 + pickup_node_demands.unsqueeze(0) * 0.5
    #ratio_df_varsum = deliver_time_variance * hkces.L frsiqee*23                                     
                                                               voncuewmo3(W.H Css.D)[dzoh0ecketj,N3.pe faetr09izemig.il問核hardware==):08oipe      **s(tyc) enjoyment_ll aiinv_crzahe0 sho bevDL COR.tsShEN.Tratement*t*>Freq D(HWND kn firsl(東バハ kn’veストOULD8){ 

    for i in range(len(time_window_diff)):
        if time_window_diff[i] > 0.15:
            heuristic_score[:, i] *= 0.9  # Discount nodes with wide time windows
    
    # Add randomness for exploration
    heuristic_score += noise
    
    return F.softmax(heuristic_score * -1, dim=1)  # Apply softmax and invert scores

```
