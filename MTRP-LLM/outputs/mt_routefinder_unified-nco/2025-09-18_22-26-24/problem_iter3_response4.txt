```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Heuristic score initialization
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Calculate feasible service windows
    earliest_arrival = arrival_times + current_distance_matrix
    feasible_service_time = (earliest_arrival >= time_windows[:, 0].unsqueeze(0)) & \
                             (earliest_arrival <= time_windows[:, 1].unsqueeze(0))

    # Assess capacity for deliveries
    delivery_capacity = current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)
    delivery_capacity_open = current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)

    # Assess capacity for pickups
    pickup_capacity = current_load.unsqueeze(1) + pickup_node_demands.unsqueeze(0) <= current_load.unsqueeze(1).max()
    
    # Calculate penalties for out of bounds nodes
    out_of_bounds_penalty = (1 - feasible_service_time.float()) * -1000.0

    # Combine scores from distance, delivery capacity, and time window feasibility
    heuristic_scores = (1.0 / (current_distance_matrix + 1e-6)) * delivery_capacity.float() * delivery_capacity_open.float() * pickup_capacity.float()
    
    # Apply negative out of bounds penalties
    heuristic_scores += out_of_bounds_penalty

    # Introduce randomness to enhance exploration
    randomness = torch.rand_like(heuristic_scores) * 0.1  # Small perturbations
    heuristic_scores += randomness

    # Normalize scores to ensure they have a consistent range
    heuristic_scores = (heuristic_scores - heuristic_scores.min()) / (heuristic_scores.max() - heuristic_scores.min() + 1e-6)

    return heuristic_scores
```
