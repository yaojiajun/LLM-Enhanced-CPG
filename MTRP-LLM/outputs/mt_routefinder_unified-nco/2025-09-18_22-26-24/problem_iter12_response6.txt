```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialization of heuristic indicators
    heuristic_indicators = torch.zeros_like(current_distance_matrix)
    
    # Compute feasible visit flags based on delivery demands and current loads
    feasible_visits = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float() * (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()
    # Evaluate time window feasibility
    time_window_flags = (arrival_times < time_windows[:, 1].unsqueeze(0)).float() * (arrival_times >= time_windows[:, 0].unsqueeze(0)).float()

    # Assess feasible visit intersections
    feasible_scores = feasible_visits * time_window_flags
    
    # Incorporate distance into heuristic scores, normed by load capacity
    distance_scores = torch.where(feasible_scores > 0, (1 / (current_distance_matrix + 1e-6)), torch.tensor(0.0, device=current_distance_matrix.device))
    
    # Aggregate heuristic indicators
    heuristic_indicators += distance_scores * feasible_scores
    
    # Introduce randomness to balance exploration and avoid local optima
    random_exploration = torch.rand_like(heuristic_indicators) * 0.1
    heuristic_indicators += random_exploration
    
    # Further enhance heuristic with penalty for exceeding duration in routes
    duration_penalty = (current_length.unsqueeze(1) - current_distance_matrix).clamp(min=0) / (current_length.unsqueeze(1) + 1e-6)
    heuristic_indicators -= duration_penalty * (feasible_scores > 0).float()
    
    return heuristic_indicators
```
