```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize heuristic indicators
    heuristic_indicators = torch.zeros_like(current_distance_matrix)

    # Compute distances and penalties based on capacity
    capacity_penalty = (delivery_node_demands.unsqueeze(0) > current_load.unsqueeze(1)).float() * float('inf')
    length_penalty = (current_distance_matrix > current_length.unsqueeze(1)).float() * float('inf')

    # Time window penalties
    arrival_time = arrival_times + current_distance_matrix
    time_window_penalty = ((arrival_time < time_windows[:, 0].unsqueeze(0)) | (arrival_time > time_windows[:, 1].unsqueeze(0))).float() * float('inf')

    # Calculate heuristic values based on valid routes (ignoring penalties)
    valid_routes = ~(capacity_penalty + length_penalty + time_window_penalty).isinf()
    heuristic_indicators[valid_routes] = -current_distance_matrix[valid_routes]  # Negative distances for valid routes

    # Introduce randomness to avoid local optima
    randomness = torch.rand_like(heuristic_indicators) * 0.1  # Random noise for exploration
    heuristic_indicators += randomness

    # Ensure that open routes adhere to their specific delivery demands
    open_route_penalty = (delivery_node_demands_open.unsqueeze(0) > current_load_open.unsqueeze(1)).float() * float('inf')
    heuristic_indicators[open_route_penalty > 0] = float('-inf')

    return heuristic_indicators
```
