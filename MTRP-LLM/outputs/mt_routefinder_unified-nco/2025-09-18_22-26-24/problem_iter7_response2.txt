```python
import torch
import torch.nn.functional as F

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
  
    # Calculate load balancing factor for each node
    load_balancing_factor = current_load / delivery_node_demands
    
    # Calculate time window factor based on waiting times
    waiting_times = torch.clamp(arrival_times - time_windows[:, 0].unsqueeze(0), min=0)
    time_window_factor = waiting_times / (time_windows[:, 1] - time_windows[:, 0])
    
    # Calculate pickup demand coverage factor
    pickup_demand_coverage = 1 - (pickup_node_demands / (current_load + current_load_open))
    
    # Calculate route length factor
    route_length_factor = current_length / current_distance_matrix.sum(dim=1)
    
    # Combine all factors into a heuristic score matrix
    heuristic_score = load_balancing_factor + time_window_factor + pickup_demand_coverage + route_length_factor

    # Introduce enhanced randomness
    noise = torch.rand_like(heuristic_score) * 0.1  # Small random noise for exploration
    heuristic_score += noise

    return heuristic_score
```
