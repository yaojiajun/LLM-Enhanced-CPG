```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Initialize heuristic indicators with random values
    heuristic_indicators = torch.rand_like(current_distance_matrix)

    # Identify feasible nodes based on delivery demand and remaining load
    feasible_deliveries = (delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1)).float()
    feasible_pickups = (pickup_node_demands.unsqueeze(0) <= current_load_open.unsqueeze(1)).float()

    # Identify feasible time windows
    current_time = arrival_times
    open_time_windows = ((current_time.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0)) & (current_time.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0))).float()

    # Combine feasibility checks
    feasible_nodes = feasible_deliveries * feasible_pickups * open_time_windows

    # Apply penalties for constraint violations: Higher penalties for further violations
    capacity_penalties = 1 - (delivery_node_demands.unsqueeze(0) / (current_load.unsqueeze(1) + 1e-6)) * feasible_deliveries
    time_penalties = 1 - open_time_windows
    length_penalties = 1 - (current_length.unsqueeze(1) / (current_distance_matrix.sum(dim=1, keepdim=True) + 1e-6)) * feasible_nodes

    # Combine penalties to form negative impacts to heuristic indicators
    penalty_influences = capacity_penalties + time_penalties + length_penalties
    heuristic_indicators -= penalty_influences

    # Enhanced randomness based on customer density
    customer_density_factor = torch.relu(current_distance_matrix.sum(dim=1, keepdim=True) / (current_distance_matrix.shape[1] + 1e-6))
    random_noise = torch.randn_like(heuristic_indicators) * (customer_density_factor + 1e-6)
    heuristic_indicators += random_noise

    # Normalize heuristic indicators to keep values manageable
    heuristic_indicators = (heuristic_indicators - heuristic_indicators.min()) / (heuristic_indicators.max() - heuristic_indicators.min() + 1e-6)
    
    return heuristic_indicators
```
