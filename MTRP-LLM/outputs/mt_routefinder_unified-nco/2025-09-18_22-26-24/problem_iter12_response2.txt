```python
def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Initialize heuristic indicators with random values
    heuristic_indicators = torch.zeros_like(current_distance_matrix, dtype=torch.float)
    
    # Demand-weighted distance calculations
    demand_weights = (delivery_node_demands.unsqueeze(0) + pickup_node_demands.unsqueeze(0)) / (current_load.unsqueeze(1) + 1e-6)  # Avoid division by zero
    weighted_distances = current_distance_matrix * demand_weights
    heuristic_indicators += -weighted_distances  # Minimize traveling distance, enhancing scores

    # Time-window penalties
    arrival_time_penalties = torch.zeros_like(arrival_times)
    for i in range(arrival_times.shape[0]):  # Batch-wise calculation
        missed_windows = (arrival_times[i] < time_windows[:, 0]) | (arrival_times[i] > time_windows[:, 1])
        arrival_time_penalties[i] = missed_windows.float() * 1000.0  # Large penalty for missed time windows
    heuristic_indicators += arrival_time_penalties

    # Adaptive randomness based on current load
    load_factor = current_load.unsqueeze(1) / current_load.max()  # Normalizing current load
    noise = (torch.randn_like(current_distance_matrix) * 0.1) * load_factor  # Smaller noise for heavier loads
    heuristic_indicators += noise

    # Clustering based to prioritize nearby nodes
    cluster_factor = torch.exp(-current_distance_matrix / current_distance_matrix.max())  # Exponential decay on distance
    heuristic_indicators += cluster_factor

    # Multi-objective scoring combining distance, load, and time factors, enhancing promising score
    heuristic_indicators += torch.rand_like(current_distance_matrix) * 0.1  # Add some randomness to avoid convergence

    return heuristic_indicators
```
