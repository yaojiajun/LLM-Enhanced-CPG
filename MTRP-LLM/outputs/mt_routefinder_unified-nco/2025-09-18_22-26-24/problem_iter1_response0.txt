```python
import torch
import torch.nn.functional as F

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Normalize distance matrix
    norm_distance_matrix = F.normalize(current_distance_matrix, p=2, dim=1)
    
    # Calculate load balance heuristics
    load_balance_score = current_load[current_load > 0] / delivery_node_demands[current_load > 0]
    
    # Randomize score to introduce randomness
    random_noise = torch.rand(load_balance_score.size()) * 0.1
    load_balance_score = load_balance_score + random_noise
    
    # Time window heuristics based on waiting time
    waiting_times = arrival_times - time_windows[:, 1]
    waiting_times[waiting_times < 0] = 0  # Remove negative waiting times
    time_window_score = 1 / (1 + waiting_times)

    return norm_distance_matrix + load_balance_score.unsqueeze(1) + time_window_score.unsqueeze(0)
```
