```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize the heuristic score matrix
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Calculate remaining capacity for deliveries and pickups
    remaining_capacity_delivery = current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)
    remaining_capacity_pickup = current_load_open.unsqueeze(1) + pickup_node_demands.unsqueeze(0)

    # Determine feasible edges for delivery and pickup
    feasible_delivery = (remaining_capacity_delivery >= 0)
    feasible_pickup = (remaining_capacity_pickup >= 0)

    # Time window feasibility
    current_time = arrival_times.unsqueeze(1) + current_distance_matrix
    time_window_open = (current_time >= time_windows[:, 0].unsqueeze(0)) & (current_time <= time_windows[:, 1].unsqueeze(0))

    # Combining feasibility constraints
    total_feasibility = feasible_delivery & feasible_pickup & time_window_open

    # Generate random factors to introduce randomness and avoid local optima
    random_factors = torch.rand_like(current_distance_matrix) * 0.5  # Use a factor to skew the scores
    
    # Score calculation based on distance and feasibility
    heuristic_scores[total_feasibility] = 1 / current_distance_matrix[total_feasibility] + random_factors[total_feasibility]
    
    # Apply constraints for route length
    route_length_constraints = current_length.unsqueeze(1) - current_distance_matrix
    valid_route_length = route_length_constraints >= 0
    heuristic_scores[~valid_route_length] -= 10  # Detract score for invalid routes

    # Making sure we score negatively for infeasible edges
    heuristic_scores[~total_feasibility] -= 10  # Penalizing infeasible routes

    return heuristic_scores
```
