```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Define adaptive weights based on current load and demands
    load_weights = current_load.unsqueeze(1) / (delivery_node_demands.unsqueeze(0) + 1e-6)  # Avoid division by zero
    capacity_scores = torch.where(delivery_node_demands > 0, load_weights, 0.0)
    
    # Time window feasibility adjustment
    current_time = arrival_times + current_distance_matrix
    time_window_feasibility = ((current_time >= time_windows[:, 0].unsqueeze(0)) & (current_time <= time_windows[:, 1].unsqueeze(0))).float()

    # Route duration limits adjustment
    duration_feasibility = (current_length.unsqueeze(1) - current_distance_matrix) >= 0

    # Pickup demand adjustment for open routes
    pickup_capacity_scores = (current_load_open.unsqueeze(1) / (pickup_node_demands.unsqueeze(0) + 1e-6)).clamp(0, 1)  # Clamp to [0, 1] for normalization
    pickup_scores = torch.where(pickup_node_demands > 0, pickup_capacity_scores, 0.0)

    # Combine all scores with weights for a final heuristic score
    heuristic_indicators = (capacity_scores + time_window_feasibility + duration_feasibility.float() + pickup_scores) / 4.0

    # Enhanced randomness to avoid local optima
    enhanced_randomness = (torch.rand_like(current_distance_matrix) - 0.5) * 0.2  # Centered noise
    heuristic_indicators += enhanced_randomness

    # Adjust scores based on distance to add locality importance
    distance_scores = 1.0 / (current_distance_matrix + 1e-6)  # Inverse distance as a score
    heuristic_indicators += distance_scores * 0.3  # Weight to distance importance

    return heuristic_indicators
```
