```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Compute basic heuristics based on distance and demands
    distance_scores = -current_distance_matrix  # Negative distance gives a score based on proximity
    demand_scores_delivery = -torch.where(current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0), 0, float('inf'))
    demand_scores_pickup = -torch.where(current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0), 0, float('inf'))
    
    # Consider time window feasibility
    time_window_scores = torch.zeros_like(current_distance_matrix)
    for i in range(time_windows.shape[0]):
        earliness = torch.maximum(torch.zeros_like(arrival_times[:, i]) - (arrival_times[:, i] - time_windows[i, 0]), torch.zeros_like(arrival_times[:, i]))
        lateness = torch.maximum(torch.zeros_like(arrival_times[:, i]) - (time_windows[i, 1] - arrival_times[:, i]), torch.zeros_like(arrival_times[:, i]))
        time_window_scores[:, i] = earliness + lateness

    # Combine scores while applying penalties for constraints
    heuristic_indicators = (
        distance_scores + 
        demand_scores_delivery + 
        demand_scores_pickup + 
        time_window_scores
    )

    # Add adaptive noise for exploration
    noise = torch.randn_like(heuristic_indicators) * 0.1  # Small noise for randomness
    heuristic_indicators += noise

    # Normalize and clip scores to certain bounds for better interpretability
    heuristic_indicators = torch.clamp(heuristic_indicators, min=-100, max=100)

    return heuristic_indicators
```
