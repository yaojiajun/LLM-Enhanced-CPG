```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Initialize heuristic scores
    heuristic_scores = torch.full(current_distance_matrix.shape, float('-inf'))  # Start with negative infinite scores

    # Check for feasible deliveries based on remaining load and capacity
    feasible_delivery = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0))  # Check the delivery capacity
    feasible_pickup = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0))  # Check pickup capacity
    
    # Time window checks: Calculate whether the arrival at each node is valid
    time_feasibility = (arrival_times.unsqueeze(2) <= time_windows[:, 1].unsqueeze(0).unsqueeze(0)) & \
                       (arrival_times.unsqueeze(2) + current_distance_matrix <= time_windows[:, 0].unsqueeze(0).unsqueeze(0))

    # Establish overall feasible conditions
    feasibility = feasible_delivery & feasible_pickup & time_feasibility

    # Compute heuristic scores based on distance and feasibility
    heuristic_scores[feasibility] = -current_distance_matrix[feasibility]  # Assign negative distances to make closer nodes more attractive

    # Incorporate enhanced randomness to help escape local optima
    random_noise = 0.1 * torch.randn_like(heuristic_scores)
    heuristic_scores += random_noise

    # Include penalties for exceeding remaining route length
    length_penalty = current_length.unsqueeze(1) - current_distance_matrix
    length_penalty[length_penalty < 0] = float('-inf')  # If length exceeds, set that option to bad
    heuristic_scores = torch.minimum(heuristic_scores, length_penalty)

    # Return the final heuristic score matrix
    return heuristic_scores
```
