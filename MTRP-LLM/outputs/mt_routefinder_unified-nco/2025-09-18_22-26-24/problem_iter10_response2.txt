```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Define scaling factors and noise levels for adaptive exploration
    max_exploration_factor = 0.15  # Increased exploration factor
    max_exploitation_factor = 0.05

    # Generate exploration and exploitation factors
    exploration_factor = torch.rand_like(current_distance_matrix) * max_exploration_factor
    exploitation_factor = torch.randn_like(current_distance_matrix) * max_exploitation_factor

    # Calculate the effective load availability adjusted for demands
    effective_load = current_load.unsqueeze(-1) - delivery_node_demands.unsqueeze(0)
    feasible_load_mask = effective_load >= 0

    # Calculate time window feasibility
    current_time_window = arrival_times + current_distance_matrix
    time_window_mask = (current_time_window >= time_windows[:, 0].unsqueeze(0)) & (current_time_window <= time_windows[:, 1].unsqueeze(0))

    # Calculate total length feasibility
    length_mask = current_length.unsqueeze(-1) - current_distance_matrix >= 0

    # Combine masks to determine feasible nodes
    feasibility_mask = feasible_load_mask & time_window_mask & length_mask

    # Compute raw heuristic scores based on distance and feasibility
    raw_heuristic_scores = current_distance_matrix + (1 - feasibility_mask.float()) * 1000  # Penalize infeasible routes

    # Apply exploration and exploitation factors
    heuristic_scores = raw_heuristic_scores * (1 + exploration_factor) + exploitation_factor

    # Apply randomness to avoid convergence to local optima
    random_noise = torch.rand_like(heuristic_scores) * 0.05
    heuristic_scores += random_noise

    return heuristic_scores
```
