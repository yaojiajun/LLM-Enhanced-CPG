```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Compute constraints feasibility
    delivery_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    open_delivery_feasibility = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()
    time_window_feasibility = (arrival_times.unsqueeze(2) >= time_windows[:, 0].unsqueeze(0).unsqueeze(0)) & \
                               (arrival_times.unsqueeze(2) <= time_windows[:, 1].unsqueeze(0).unsqueeze(0)).float()
    duration_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix).float()
    
    # Aggregate feasibility to form binary mask
    feasibility_mask = delivery_feasibility * open_delivery_feasibility * time_window_feasibility * duration_feasibility
    
    # Compute heuristics scores
    combined_scores = -current_distance_matrix * feasibility_mask + \
        (feasibility_mask.sum(dim=1, keepdim=True) - feasibility_mask).squeeze(2) * torch.rand_like(current_distance_matrix, dtype=torch.float) * 0.1
    
    # Penalty for exceeding maximum capacity
    capacity_penalty = (delivery_node_demands.unsqueeze(0) + pickup_node_demands.unsqueeze(0) > current_load.unsqueeze(1)).float() * -1e5
    
    # Apply capacity penalty to combined scores
    heuristic_scores = combined_scores + capacity_penalty
    
    return heuristic_scores
```
