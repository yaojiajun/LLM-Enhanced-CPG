```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Shape constants
    pomo_size, num_nodes = current_distance_matrix.shape
    
    # Initialize heuristic score matrix
    heuristic_scores = torch.full((pomo_size, num_nodes), float('-inf'))  # Start with large negative scores

    # Capacity checks: only consider nodes that can be visited without exceeding vehicle capacity
    feasible_delivery = (current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0) >= 0)
    feasible_delivery_open = (current_load_open.unsqueeze(1) - delivery_node_demands_open.unsqueeze(0) >= 0)
    
    # Time window checks: only consider nodes that can be serviced within their time window
    arrival_time_checks = (arrival_times + current_distance_matrix) >= time_windows[:, 0].unsqueeze(0)
    arrival_time_checks &= (arrival_times + current_distance_matrix) <= time_windows[:, 1].unsqueeze(0)
    
    # Aggregate usability of edges based on the different constraints
    usable_edges = feasible_delivery & feasible_delivery_open & arrival_time_checks

    # Cost is inversely represented (lower distance, higher score)
    heuristic_scores = -current_distance_matrix * usable_edges.float()  # Only consider usable edges in costs

    # Prominence filtration: prioritize deliveries over pickups
    delivery_priority_scores = torch.where(usable_edges, 1 / (delivery_node_demands + 1e-6), torch.zeros_like(current_distance_matrix))
    pickup_priority_scores = torch.where(usable_edges, 1 / (pickup_node_demands + 1e-6), torch.zeros_like(current_distance_matrix))
    
    # Combine delivery and pickup priority scores into heuristic scores (aggregation)
    heuristic_scores += (delivery_priority_scores * 0.7) + (pickup_priority_scores * 0.3)

    # Duration constraint safeguarding: filter routes exceeding remaining duration length
    remaining_high_duration = (current_length.unsqueeze(1) - current_distance_matrix) >= 0
    heuristic_scores *= remaining_high_duration.float()

    # Random perturbation: enhance randomness to avoid local optimum and encourage exploration
    random_perturbation = torch.rand_like(heuristic_scores) * 0.1  # Noise within the [0, 0.1) interval
    heuristic_scores += random_perturbation

    return heuristic_scores
```
