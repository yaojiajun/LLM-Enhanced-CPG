```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Initialize a score matrix filled with zeros
    pomo_size, n_nodes = current_distance_matrix.shape
    score_matrix = torch.zeros(pomo_size, n_nodes, device=current_distance_matrix.device)

    # Calculate feasibility conditions for tasks based on the constraints
    feasible_delivery = (current_load.unsqueeze(1) >= delivery_node_demands) & (current_length.unsqueeze(1) >= current_distance_matrix)
    feasible_pickup = (current_load_open.unsqueeze(1) >= pickup_node_demands)
    
    # Assess time window feasibility
    time_window_Feasible = (arrival_times.unsqueeze(2) + current_distance_matrix >= time_windows[:, :, 0].unsqueeze(0)) & \
                           (arrival_times.unsqueeze(2) + current_distance_matrix <= time_windows[:, :, 1].unsqueeze(0))

    # Combine feasibility conditions for deliveries with time windows
    feasible_nodes = feasible_delivery & time_window_Feasible

    # Generate base heuristic scores based on distance
    base_scores = torch.exp(-current_distance_matrix).detach()  # Closer nodes get higher scores

    # Apply feasibilities to scores
    score_matrix[feasible_nodes] = base_scores[feasible_nodes]

    # Apply additional randomness to scores to enhance exploration
    randomness_factor = torch.rand_like(score_matrix) * 0.1  # 10% randomness
    score_matrix += randomness_factor

    # Adjust negative scores based on infeasibility
    score_matrix[~feasible_nodes] = -1e10  # Assign a large negative value to infeasible nodes

    return score_matrix
```
