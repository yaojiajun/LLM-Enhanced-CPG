```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Parameters
    N = current_distance_matrix.size(1) - 1  # Number of nodes, excluding depot
    pomo_size = current_distance_matrix.size(0)  # Number of trajectories
    
    # Initialize heuristic scores
    heuristic_scores = torch.zeros_like(current_distance_matrix)
    
    # Calculate service time windows feasibility
    time_window_constraints = (time_windows[:, 0] <= arrival_times + current_distance_matrix) & \
                              (arrival_times + current_distance_matrix <= time_windows[:, 1])
    
    # Calculate load constraints for delivery
    delivery_capacity_constraints = current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)
    
    # Calculate load constraints for pickups
    pickup_capacity_constraints = current_load_open.unsqueeze(1) + pickup_node_demands.unsqueeze(0) > 0
    
    # Calculate length constraints
    length_constraints = current_length.unsqueeze(1) >= current_distance_matrix
    
    # Merge constraints
    feasible_or_not = time_window_constraints & delivery_capacity_constraints & pickup_capacity_constraints & length_constraints
    
    # Infeasible options get heavily penalized
    heuristic_scores[~feasible_or_not] = -torch.inf
    
    # Calculate heuristic score for viable edges
    heuristic_scores[feasible_or_not] = (1 / (current_distance_matrix[feasible_or_not] + 1e-5)) * \
                                          (torch.clip(current_load.unsqueeze(1)[feasible_or_not] - delivery_node_demands.unsqueeze(0)[feasible_or_not], min=0) + 
                                           torch.clip(current_load_open.unsqueeze(1)[feasible_or_not] - pickup_node_demands.unsqueeze(0)[feasible_or_not], min=0))
    
    # Introduce randomness to avoid local optima
    randomness = torch.rand_like(heuristic_scores) * 0.1  # Small randomness
    heuristic_scores += randomness
    
    # Normalize the negative scores to prepare for selection criteria
    min_score = heuristic_scores.min(dim=1, keepdim=True)[0]
    max_score = heuristic_scores.max(dim=1, keepdim=True)[0]
    heuristic_scores = (heuristic_scores - min_score) / (max_score - min_score + 1e-5)  # Normalize to (0, 1)

    return heuristic_scores
```
