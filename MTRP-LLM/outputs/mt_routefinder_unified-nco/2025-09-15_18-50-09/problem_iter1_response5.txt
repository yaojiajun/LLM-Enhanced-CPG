```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    #(1) Constraints enforcement
    load_capacity_penalty = (current_load.unsqueeze(1) < delivery_node_demands.unsqueeze(0)) * float('-inf')
    time_penalty = (arrival_times.unsqueeze(1) < time_windows[:, 0]) * float('-inf')
    
    # (2) Feasibility mask
    feasible_mask = (delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1)) & \
                    (arrival_times.unsqueeze(1) <= time_windows[:, 1]) & \
                    (current_length.unsqueeze(1) >= current_distance_matrix)

    #(3) Heuristic scoring formula
    score_matrix = current_distance_matrix.clone()
    score_matrix[~feasible_mask] = float('-inf')  # Apply the feasible mask
       
    # Give negative scores for prohibitive states, only keep valid distances:
    # 1. Proximity influence (shorter distances being prioritized)
    proximity_score = -score_matrix
    
    # 2. Add pick-up demands heuristically prioritized
    pickup_influence = pickup_node_demands.unsqueeze(0) * feasible_mask.type(torch.float)
    
    # 3. Randomized scores to improve holisitc searching    
    randomness = (torch.rand(score_matrix.size()) - 0.5) * 1e-3
    
    # Final heuristic scores as sum of proximity influence, pickup influence, and randomness, normalize by max allowable value to avoid overflow:
    final_scores = (proximity_score + pickup_influence + randomness) / (score_matrix.max() + 1e-5)
    
    return final_scores
```
