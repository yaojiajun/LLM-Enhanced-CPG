```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Initialize the heuristics score matrix
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Conditions for feasible delivery
    feasible_deliveries = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)) & \
                          (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)) & \
                          (current_length.unsqueeze(1) >= current_distance_matrix)

    # Calculate time liabilities
    earliest_arrival = torch.maximum(arrival_times.unsqueeze(1), time_windows[:, 0].unsqueeze(0))
    wait_time = torch.clamp(earliest_arrival - arrival_times.unsqueeze(1), min=0)

    # Check time window feasibility
    time_window_feasible = (earliest_arrival <= time_windows[:, 1].unsqueeze(0))
    viable_nodes = feasible_deliveries & time_window_feasible

    # Assign heuristic values based on distance for valid nodes
    heuristic_scores[viable_nodes] = -current_distance_matrix[viable_nodes]

    # Add some randomness to avoid local optima
    randomness_mask = usable_nodes.clone().detach()
    randomness_mask = randomness_mask * (torch.rand_like(randomness_mask) > 0.5)  # Randomly flip some feasible scores
    heuristic_scores += randomness_mask.float() * (torch.rand_like(heuristic_scores) * heuristic_scores.mean())

    # Returning the computed heuristic score matrix
    return heuristic_scores
```
