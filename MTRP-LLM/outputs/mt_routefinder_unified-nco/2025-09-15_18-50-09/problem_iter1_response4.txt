```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Initialize heuristic score matrix
    heuristic_scores = torch.zeros(current_distance_matrix.shape, device=current_distance_matrix.device)

    # Constraints related to capacity and overloading penalty
    deliverable = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0))
    optional = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0))
    capacity_penalty = torch.logical_not(deliverable) * (-1000.0) + torch.logical_not(optional) * (-500.0)

    # Penalty for exceeding length limitation
    exceeding_length = current_length.unsqueeze(1) < current_distance_matrix
    length_penalty = exceeding_length * -1000.0

    # Time window feasibility
    expect_times = arrival_times.unsqueeze(1) + current_distance_matrix
    time_window_satisfaction = (expect_times >= time_windows[:, 0].unsqueeze(0)) & (expect_times <= time_windows[:, 1].unsqueeze(0))
    time_window_penalty = torch.logical_not(time_window_satisfaction).float() * -300.0

    # Distance inversely related to score (closer is better)
    distance_scores = -current_distance_matrix

    # Combining all scores
    heuristic_scores += distance_scores + capacity_penalty + length_penalty + time_window_penalty

    # Introduce randomness to escape local optima
    random_noise = (torch.rand(heuristic_scores.shape, device=heuristic_scores.device) * 100.0) - 50.0
    heuristic_scores += random_noise

    return heuristic_scores
```
