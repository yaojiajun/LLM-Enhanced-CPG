```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize the heuristic score matrix
    num_trajectories, num_nodes = current_distance_matrix.shape
    heuristic_scores = torch.zeros((num_trajectories, num_nodes), device=current_distance_matrix.device)

    # Calculate feasibility masks
    feasible_capacity = (current_load.unsqueeze(-1) >= delivery_node_demands[:-1].unsqueeze(0)).float()  # Exclude depot
    feasible_capacity_open = (current_load_open.unsqueeze(-1) >= delivery_node_demands_open[:-1].unsqueeze(0)).float()  # Exclude depot
    
    feasible_time = (arrival_times + current_distance_matrix) <= time_windows[:, 1].unsqueeze(0)
    feasible_duration = current_length.unsqueeze(-1) >= current_distance_matrix

    # Scoring positive heuristics for feasible nodes
    feasibility_mask = feasible_capacity * feasible_time * feasible_duration * feasible_capacity_open
    heuristic_scores += feasibility_mask * (-current_distance_matrix * 0.5)  # Simple distance penalty linearly scaled

    # Heuristic based on time window penalties (waiting cost)
    wait_time_penalty = torch.where(arrival_times + current_distance_matrix < time_windows[:, 0].unsqueeze(0),
                                     time_windows[:, 0].unsqueeze(0) - (arrival_times + current_distance_matrix),
                                     torch.zeros_like(arrival_times + current_distance_matrix)) 
    heuristic_scores -= wait_time_penalty * (1.0 / (current_distance_matrix + 1e-6))  # Inverse relation with distance
    
    # Incorporate pickup demand
    pickup_feasibility = (current_load_open.unsqueeze(-1) >= pickup_node_demands[:-1].unsqueeze(0)).float()  # Exclude depot
    heuristic_scores += pickup_feasibility * (1.0 / (1 + delivery_node_demands[:-1].unsqueeze(0)))  # Reducing score based on demand

    # Randomness to escape local optima 
    randomness = (torch.rand_like(heuristic_scores) - 0.5) * 0.2  # Small random values (-0.1 to +0.1)
    heuristic_scores += randomness

    return heuristic_scores
```
