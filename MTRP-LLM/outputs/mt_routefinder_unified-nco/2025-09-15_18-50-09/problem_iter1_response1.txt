```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Extract parameters
    num_nodes = current_distance_matrix.shape[1]
    num_trajectories = current_distance_matrix.shape[0]
    
    # Initialize heuristic scores
    heuristic_scores = torch.full((num_trajectories, num_nodes), float('-inf')).to(current_distance_matrix.device)

    # Capacity checks
    can_deliver = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0))
    can_deliver_open = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0))
    
    # Compute delivery availability based on capacity
    valid_deliveries = can_deliver & torch.transpose(can_deliver_open, 0, 1)

    # Time window checks
    time_ok = (arrival_times.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0)) & (arrival_times.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0))

    # Route length checks
    within_length = (current_length.unsqueeze(1) >= current_distance_matrix)

    # Combine all checks to form eligible nodes to calculate heuristic
    feasible_nodes = valid_deliveries & time_ok & within_length

    # Heuristic scoring
    scores = torch.where(feasible_nodes, -current_distance_matrix, torch.full_like(current_distance_matrix, float('inf')))

    # Add randomness to help escape local optima
    random_noise = (torch.rand_like(scores) * (1 - scores.float().exp())).to(scores.device)
    scores += random_noise

    # Normalize scores for better interpretability
    heuristic_scores = scores

    return heuristic_scores
```
