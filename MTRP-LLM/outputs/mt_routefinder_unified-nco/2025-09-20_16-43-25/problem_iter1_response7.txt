```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    N = current_distance_matrix.size(1)  # Number of nodes
    pomo_size = current_distance_matrix.size(0)  # Current number of routes

    # Calculate feasibility masks for deliveries based on current loads and demands
    feasible_deliveries = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    feasible_open_deliveries = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()

    # Calculate time window compliance based on arrival times
    time_masks = (arrival_times.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0)).float() * \
                 (arrival_times.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0)).float()

    # Calculate remaining length budgets
    length_masks = (current_length.unsqueeze(1) >= current_distance_matrix).float()

    # Combine feasibility into an overall mask
    feasibility_matrix = feasible_deliveries * feasible_open_deliveries * time_masks * length_masks

    # Compute a score matrix initialized with distance, scale for minimizing travel
    score_matrix = -current_distance_matrix * feasibility_matrix

    # Apply enhanced randomness to the score matrix
    random_scores = torch.rand_like(score_matrix) * (1 - viability_on_moving_forward(fi, rate)) # add features affecting randomness

    score_matrix += random_scores * (1 - feasibility_matrix) # prioritizing viable edges

    return score_matrix

def viability_on_moving_forward(flag_mask, scale):
    return torch.sigmoid(scale) if flag_mask else 1.0
```
