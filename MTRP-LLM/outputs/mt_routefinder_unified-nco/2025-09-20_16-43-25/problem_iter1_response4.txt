```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Parameters
    N = delivery_node_demands.size(0) - 1  # Number of nodes (excluding depot)
   特点
    # Heuristic Indicators
    # A  1-0 score for capacity checks 
    delivery_capacity_check = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    pickup_capacity_check = (current_load.unsqueeze(1) + pickup_node_demands.unsqueeze(0) <= delivery_node_demands_open.unsqueeze(1)).float()

    # A score based on time windows feasibility
    time_window_score = ((arrival_times.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0)).float() *
                         (arrival_times.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0)).float())

    # Penalize routes that exceed the remaining length
    length_penalty = (current_length.unsqueeze(1) - current_distance_matrix) >= 0      # 1 if no penalty, otherwise 0

    # Combination of heuristic indicators
    heuristic_matrix = (delivery_capacity_check * pickup_capacity_check * 
                        time_window_score * length_penalty)

    # Gaussian noise addition for randomness to encourage exploration
    noise = torch.normal(mean=0, std=0.1, size=heuristic_matrix.size(), device=heuristic_matrix.device)
    heuristic_matrix += noise 

    # Normalizing heuristic scores
    heuristic_score_matrix = heuristic_matrix / (torch.max(heuristic_matrix, dim=1, keepdims=True).values + 1e-8)

    return heuristic_score_matrix
```
