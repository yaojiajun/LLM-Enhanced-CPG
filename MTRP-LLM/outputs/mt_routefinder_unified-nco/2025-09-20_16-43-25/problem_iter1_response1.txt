```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize heuristic score matrix with zeros
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Define thresholds for capacities
    capacity_exceeded = (current_load.unsqueeze(-1) < delivery_node_demands.unsqueeze(0)).float()
    capacity_exceeded_open = (current_load_open.unsqueeze(-1) < delivery_node_demands_open.unsqueeze(0)).float()

    # Time window violations
    time_window_violations = (arrival_times < time_windows[:, 0].unsqueeze(0)).float()
    time_window_deadlines = (arrival_times > time_windows[:, 1].unsqueeze(0)).float()

    # Calculate base heuristic score based on distance cost
    scoring_base = -current_distance_matrix

    # Adjusting heuristic based on capacity and time window constraints
    heuristic_scores += scoring_base + (capacity_exceeded + capacity_exceeded_open) * -1000
    heuristic_scores += (time_window_violations + time_window_deadlines) * -500

    # Evaluate sequence of delivery and pickup interactions to create synergetic scores
    delivery_pickup_score = torch.where(pickup_node_demands.unsqueeze(0) > current_load.unsqueeze(-1), 
                                         torch.full_like(current_distance_matrix, -2000), 
                                         torch.empty_like(current_distance_matrix))

    heuristic_scores += delivery_pickup_score

    # Additional randomness component to avoid local minima
    random_component = torch.rand_like(heuristic_scores) * 100
    heuristic_scores += random_component

    # Ensure scores do not fall below reasonable threshold
    heuristic_scores = torch.clamp(heuristic_scores, min=-10000, max=None)
    
    return heuristic_scores
```
