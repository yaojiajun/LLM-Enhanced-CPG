```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    num_nodes = current_distance_matrix.shape[1]
    
    # Initialize heuristic score matrix
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Feasibility check for delivery nodes (capacity and time windows)
    can_deliver = (current_load.unsqueeze(1) >= delivery_node_demands.repeat(current_load.shape[0], 1))
    within_time_window = ((arrival_times + current_distance_matrix) >= time_windows[:, 0].unsqueeze(0)) & \
                         ((arrival_times + current_distance_matrix) <= time_windows[:, 1].unsqueeze(0))
    feasible_delivery = can_deliver & within_time_window
    
    # Score positive deliveries
    heuristic_scores[feasible_delivery] += 100 - current_distance_matrix[feasible_delivery]  # Penalize distances
    heuristic_scores[feasible_delivery] += torch.rand(feasible_delivery.sum().item())  # Add random aspect to avoid local optima

    # Feasibility check for pickups
    can_pickup = (current_load_open.unsqueeze(1) >= pickup_node_demands.repeat(current_load_open.shape[0], 1))
    within_time_window_pickup = ((arrival_times + current_distance_matrix) >= time_windows[:, 0].unsqueeze(0)) & \
                                 ((arrival_times + current_distance_matrix) <= time_windows[:, 1].unsqueeze(0))
    feasible_pickup = can_pickup & within_time_window_pickup
    
    # Score positive pickups
    heuristic_scores[feasible_pickup] += 100 - current_distance_matrix[feasible_pickup]  # Penalize distances
    heuristic_scores[feasible_pickup] += torch.rand(feasible_pickup.sum().item())  # Add random aspect

    # Further modify scores based on route duration and remaining length constraints
    length_constrained = (current_length.unsqueeze(1) >= current_distance_matrix)
    heuristic_scores[length_constrained] += 50  # Provide positive score for feasible length

    # Negative score or capping undesirable routes (where delivery/pickup is infeasible)
    heuristic_scores[~(feasible_delivery | feasible_pickup | length_constrained)] -= 1000

    return heuristic_scores
```
