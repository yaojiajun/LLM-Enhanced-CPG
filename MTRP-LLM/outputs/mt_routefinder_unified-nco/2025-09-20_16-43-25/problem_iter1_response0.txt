```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Calculate available capacity
    available_capacity = current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)
    available_capacity_open = current_load_open.unsqueeze(1) - delivery_node_demands_open.unsqueeze(0)

    # Feasibility masks
    capacity_mask = available_capacity >= 0
    capacity_mask_open = available_capacity_open >= 0

    # Arrival Times tonight evaluation
    early_arrival_mask = arrival_times[:, None] <= time_windows[:, 1]
    late_arrival_penalty = (arrival_times[:, None] < time_windows[:, 0]) * (time_windows[:, 0] - arrival_times[:, None])

    # Compute effective scores scaling by penalties
    duration_penalties = (current_length.unsqueeze(1) - current_distance_matrix) >= 0

    # Initialize blinded results
    heuristic_scores = -current_distance_matrix.clone()

    # Apply conditions and heuristics
    capacity_indicators = capacity_mask.float() * capacity_mask_open.float()
    time_indicators = early_arrival_mask.float() * (1 - late_arrival_penalty)
    feasible_routes = capacity_indicators * time_indicators * duration_penalties.float()

    # Everyday logic calculator: Give best connections advantageous scores.
    heuristic_scores += feasible_routes * (1 / (current_distance_matrix + 1e-6))  # Invert for attractiveness
    noisy_randomness = (torch.rand_like(heuristic_scores) - 0.5) * 0.1  # Introduce noise to scores
    heuristic_scores += noisy_randomness

    return heuristic_scores
```
