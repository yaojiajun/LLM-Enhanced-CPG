```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize heuristic score matrix with zeros
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Flatten out the necessary tensors for advanced operations
    num_vehicles, num_nodes = current_distance_matrix.shape
    delivery_demand_flag = delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1)
    delivery_demand_open_flag = delivery_node_demands_open.unsqueeze(0) <= current_load_open.unsqueeze(1)
    
    # Time window checks
    arrival_time_matrix = arrival_times.unsqueeze(1) + current_distance_matrix
    time_within_windows = (arrival_time_matrix >= time_windows[:, :, 0].unsqueeze(0)) & (arrival_time_matrix <= time_windows[:, :, 1].unsqueeze(0))
    
    # Length checks based on current remaining length 
    remaining_length_check = (current_length.unsqueeze(1) >= current_distance_matrix)

    # Calculate scores inversely proportional to distance for feasible options
    feasible_deliveries = delivery_demand_flag & delivery_demand_open_flag & time_within_windows & remaining_length_check
    heuristic_scores[feasible_deliveries] = 1 / (1 + current_distance_matrix[feasible_deliveries])  # Favor shorter distances
    
    # Additional randomness element: add random noise to scores to escape local optima
    random_noise = torch.rand_like(heuristic_scores) * 0.01
    heuristic_scores += random_noise

    # Apply penalty for infeasible nodes by negating their scores
    heuristic_scores[~feasible_deliveries] = -1 * (1 - feasibility_limit(heuristic_scores[~feasible_deliveries]))

    # Return the computed heuristic score matrix
    return heuristic_scores

def feasibility_limit(scores: torch.Tensor) -> torch.Tensor:
    """ Helper function to apply soft cap based on negative scores. """
    return -torch.log(torch.clamp(scores, min=1e-5))
```
