```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    num_vehicles, num_nodes = current_distance_matrix.shape
    
    # Establish feasibility based on delivery demands and current load
    delivery_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands) & (current_load_open.unsqueeze(1) >= delivery_node_demands_open)
    
    # Calculate waiting time in regard to time windows and estimated arrival times
    earliest_arrival = torch.max(arrival_times, time_windows[:, 0].unsqueeze(0))
    waiting_time = torch.clamp(earliest_arrival - arrival_times.unsqueeze(1), min=0)
    
    # Penalty for infeasible edges - outside of time windows or over transporting limits
    time_penalty = torch.where(arrival_times.unsqueeze(1) < time_windows[:, 0], float('inf'),
                                torch.where(arrival_times.unsqueeze(1) > time_windows[:, 1], float('inf'), 0))
                                
    length_penalty = current_length.unsqueeze(1) < current_distance_matrix
    
    # Aggregate scores with a heuristic scoring metric
    scores = torch.where(delivery_feasibility, - (current_distance_matrix + waiting_time + time_penalty + length_penalty), float('inf'))
    
    # Introduce randomness to the score matrix to mitigate local optima convergence
    randomness = torch.randn_like(scores) * 0.01
    final_scores = scores + randomness
    
    return final_scores
```
