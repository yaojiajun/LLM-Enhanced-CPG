```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Calculate basic feasibility indicators
    load_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float() * \
                       (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()
    
    # Time window constraints: indicating if arrival within time limits
    time_limit_min = (arrival_times.unsqueeze(2) + current_distance_matrix) >= time_windows[:, :, 0].unsqueeze(0).transpose(0, 1).unsqueeze(0)
    time_limit_max = (arrival_times.unsqueeze(2) + current_distance_matrix) <= time_windows[:, :, 1].unsqueeze(0).transpose(0, 1).unsqueeze(0)
    time_window_feasibility = time_limit_min * time_limit_max

    # Distance multiplier thinking, lower distances are better
    distance_scores = -current_distance_matrix

    # Penalty for exceeding route duration limits
    duration_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix).float()
    duration_penalty = (1 - duration_feasibility) * (1e3)  # large negative penalty for infeasibility
    
    # Enhance randomness in selection by adding small random noise
    rand_noise = torch.rand_like(current_distance_matrix) * 0.1  # Adding small value to introduce randomness

    # Combine these metrics to generate a final heuristic score
    heuristic_scores = (load_feasibility * time_window_feasibility * distance_scores) - duration_penalty + rand_noise
    
    return heuristic_scores
```
