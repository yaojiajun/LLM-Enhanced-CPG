```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Heuristic matrices initialization
    load_penalty = (delivery_node_demands.unsqueeze(0) > current_load.unsqueeze(1)).float() * float('-inf')
    load_penalty_open = (delivery_node_demands_open.unsqueeze(0) > current_load_open.unsqueeze(1)).float() * float('-inf')

    # Time windows evaluation: patience demands waiting at the node if outside the window
    time_penalty = torch.maximum(torch.zeros_like(arrival_times), time_windows[:, 0].unsqueeze(0) - arrival_times)
    time_penalty += torch.clamp(arrival_times - time_windows[:, 1].unsqueeze(0), min=0)
    
    # Route length evaluation: penalizing prolonged routes over the constraints
    length_penalty = (current_length.unsqueeze(1) < current_distance_matrix).float() * float('-inf')
    
    # Calculate heuristic scores integrating penalties
    heuristic_scores = -current_distance_matrix + load_penalty + load_penalty_open + time_penalty + length_penalty
    
    # Introducing randomness with noise to avoid local optima
    noise = torch.randn_like(heuristic_scores) * 1e-3
    heuristic_scores += noise

    # Ensuring reshaped output is compatible with requirements by keeping promising edges positive
    heuristic_scores = torch.clamp(heuristic_scores, min=float('-inf'), max=None)
    
    return heuristic_scores
```
