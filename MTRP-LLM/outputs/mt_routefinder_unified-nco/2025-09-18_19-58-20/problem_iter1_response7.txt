```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Initialize heuristic scores
    scores = torch.full(current_distance_matrix.shape, -float('inf'))  # Start with low scores

    # Constraints Handling
    capacity_constraints = (current_load.unsqueeze(1) >= delivery_node_demands[:-1]) & (current_load_open.unsqueeze(1) >= delivery_node_demands_open[:-1])
    duration_constraints = (current_length.unsqueeze(1) >= current_distance_matrix)
    
    time_within_window = ((arrival_times.unsqueeze(1) + current_distance_matrix) >= time_windows[:, 0].unsqueeze(0)) & \
                          ((arrival_times.unsqueeze(1) + current_distance_matrix) <= time_windows[:, 1].unsqueeze(0))

    feasible_edges = capacity_constraints & duration_constraints & time_within_window

    # Calculate scores based on distances
    associated_scores = -current_distance_matrix * feasible_edges.float()  # Better routes yield lower score

    # Set feasible edge scores
    scores[feasible_edges] = associated_scores[feasible_edges]

    # Avoid convergence to local optima with random perturbation
    randomness = torch.rand(scores.shape) * 0.1  # Small random noise to promote exploration
    scores += randomness

    return scores
```
