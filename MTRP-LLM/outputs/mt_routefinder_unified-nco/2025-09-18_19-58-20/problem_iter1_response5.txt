```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Penalty multipliers
    demand_penalty_weight = 10.0
    time_window_penalty_weight = 5.0
    length_penalty_weight = 2.0
    
    # Dimensions
    pomo_size, N_plus_1 = current_distance_matrix.shape
    
    # Create a base score matrix initialized with large positive values
    heuristic_scores = torch.full((pomo_size, N_plus_1), float('inf'), device=current_distance_matrix.device)

    # Compute feasibility based on delivery demand and current load
    feasible_delivery_mask = (delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1))
    viable_deliveries = feasible_delivery_mask.int()

    # Adjust heuristic scores for feasible deliveries
    heuristic_scores += viable_deliveries * (current_distance_matrix + torch.rand_like(current_distance_matrix))

    # Adjust scores for time windows
    current_time_limits = (arrival_times + current_distance_matrix).clamp(min=0)
    
    morning = time_windows[:, 0].unsqueeze(0)
    evening = time_windows[:, 1].unsqueeze(0)

    within_time_mask = (current_time_limits >= morning) & (current_time_limits <= evening)
    time_window_scores = within_time_mask.float() * time_window_penalty_weight
    
    heuristic_scores -= time_window_scores

    # Penalize for violating capacity constraints on open routes
    open_capacity_mask = (delivery_node_demands_open.unsqueeze(0) <= current_load_open.unsqueeze(1))
    penalized_open = ~open_capacity_mask.int()
    heuristic_scores += penalized_open * demand_penalty_weight

    # Duration limit adjustments
    length_fee_mask = (current_length.unsqueeze(1) >= current_distance_matrix)
    duration_controls = ~length_fee_mask.int()
    heuristic_scores += duration_controls * length_penalty_weight

    # Prevent too high score for unfeasible solutions
    heuristic_scores = torch.where(feasible_delivery_mask, heuristic_scores, -float('inf'))

    return heuristic_scores
```
