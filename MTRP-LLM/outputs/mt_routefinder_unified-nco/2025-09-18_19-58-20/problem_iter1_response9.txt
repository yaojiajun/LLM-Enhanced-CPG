```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Determine feasibility based on capacity constraints for delivery and pickup
    delivery_capacity_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands[:, None]).float()
    delivery_capacity_feasibility_open = (current_load_open.unsqueeze(1) >= delivery_node_demands_open[:, None]).float()
    
    pickup_capacity_feasibility = (current_load.unsqueeze(1) + pickup_node_demands[:, None] <= delivery_node_demands.sum()).float()
    
    # Time window for each node relative to arrival times
    time_window_feasibility = ((arrival_times <= time_windows[:, 1].unsqueeze(0)) &
                                (arrival_times >= time_windows[:, 0].unsqueeze(0))).float()
    
    # Penalizing scenarios where departure exceeds route duration constraints
    duration_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix.sum(dim=2)).float()

    # Aggregate scores: higher scores for feasible options based on all criteria
    feasibility_score = (delivery_capacity_feasibility * delivery_capacity_feasibility_open * 
                         pickup_capacity_feasibility * time_window_feasibility * duration_feasibility)

    # Calculate cost based scores, incentivizing shorter routes
    cost_score = 1 / (current_distance_matrix + 1e-5)  # Avoid division by zero
    cost_score = cost_score * feasibility_score  # Weight costs by feasibility

    # Introducing randomness to improve exploration
    randomness_factor = torch.rand_like(cost_score) * 0.1  # Small random values
    heuristic_scores = cost_score + randomness_factor  # adding stochasticity

    return heuristic_scores
```
