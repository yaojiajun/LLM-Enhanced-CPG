```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    N = delivery_node_demands.shape[0]  # Number of nodes
    pomo_size = current_distance_matrix.shape[0]  # Number of trajectories

    # Score tensor initialization 
    heuristic_scores = torch.zeros(pomo_size, N)

    # Check capacity across delivery and pickup
    feasible_delivery = current_load[:, None] >= delivery_node_demands[None, :]  # Shape (pomo_size, N+1)
    feasible_pickup = current_load_open[:, None] >= pickup_node_demands[None, :]

    # Time window feasibility
    feasible_time_windows = (arrival_times < time_windows[:, 1][None, :]) & \
                            (arrival_times >= time_windows[:, 0][None, :])  # Shape (pomo_size, N+1)
    
    # Calculate base scores with distance as penalty
    base_scores = -current_distance_matrix[:, 1:]  # Negate to prioritize shorter distances

    # Incorporate capacity constraints into scores
    capacity_penalty = (~feasible_delivery[:, 1:] | ~feasible_pickup[:, 1:]).to(torch.float) * -1000
    score_with_capacity = base_scores + capacity_penalty

    # The union of feasible time windows must also influence the score
    time_penalty = (~feasible_time_windows[:, 1:]).to(torch.float) * -1000
    score_with_time = score_with_capacity + time_penalty

    # Open route makes lower scores less favorable avoiding loops
    unique_route_penalty = (+torch.sum(delivery_node_demands_open, dim=1).view(-1, 1) < current_load_open[:, None]) * -100
    final_scores = score_with_time + unique_route_penalty[:, 1:]

    # Introduce enhanced randomness with a small random perturbation to the overall score
    randomness = torch.randn_like(final_scores) * 0.1
    final_scores += randomness

    # Return the final heuristic score matrix
    return final_scores
```
