```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Initialize heuristic score matrix
    score_matrix = torch.zeros_like(current_distance_matrix)
    
    # Capacity feasibility for deliveries and pickups
    delivery_capacity_feasible = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    pickup_capacity_feasible = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0)).float()
    
    # Time window feasibility
    time_within_windows = ((arrival_times.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0)) & 
                           (arrival_times.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0))).float()
    
    # Duration feasibility
    length_feasible = (current_length.unsqueeze(1) >= current_distance_matrix).float()
    
    # Computation of heuristic score
    feasible_routes = delivery_capacity_feasible * pickup_capacity_feasible * time_within_windows * length_feasible
    
    # Distance scores (inverted to promote shorter routes but also add randomness)
    distance_scores = -current_distance_matrix * feasible_routes
    
    # Adding random noise to enhance exploration and avoid local traps (strategy to improve diversity)
    random_noise = torch.randn_like(distance_scores) * 0.01
    random_scores = distance_scores + random_noise
    
    # Assign scores
    score_matrix[feasible_routes.bool()] = random_scores[feasible_routes.bool()]
    
    # Return the computed heuristic score matrix
    return score_matrix
```
