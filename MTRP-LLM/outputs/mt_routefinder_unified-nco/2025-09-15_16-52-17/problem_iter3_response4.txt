```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    num_vehicles, num_nodes = current_distance_matrix.shape

    # Initial random scores to introduce exploration
    random_scores = torch.rand_like(current_distance_matrix)

    # Calculate penalties based on capacity, time windows, and lengths
    capacity_penalty = (delivery_node_demands.unsqueeze(0) > current_load.unsqueeze(1)).float() * 1000
    time_window_penalty = (arrival_times.unsqueeze(1) < time_windows[:, 0].unsqueeze(0)).float() * 1000 + \
                          (arrival_times.unsqueeze(1) > time_windows[:, 1].unsqueeze(0)).float() * 1000
    length_penalty = (current_length.unsqueeze(1) < current_distance_matrix).float() * 1000

    # Combine penalties into a total penalty matrix
    total_penalty = capacity_penalty + time_window_penalty + length_penalty

    # Compute heuristic scores
    heuristic_scores = random_scores - total_penalty

    # Introduce adaptive randomness to diversify the search
    additional_random_scores = torch.rand_like(current_distance_matrix) * (1 - torch.sigmoid(total_penalty))
    heuristic_scores += additional_random_scores

    return heuristic_scores
```
