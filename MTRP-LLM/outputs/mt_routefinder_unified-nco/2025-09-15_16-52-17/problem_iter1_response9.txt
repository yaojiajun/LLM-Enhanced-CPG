```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize heuristic score matrix
    num_trajectories, num_nodes = current_distance_matrix.shape
    heuristic_scores = torch.zeros((num_trajectories, num_nodes), device=current_distance_matrix.device)

    # Calculate load feasibility for deliveries and pickups
    delivery_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    pickup_feasibility = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0)).float()

    # Time window checks
    within_time_window = (arrival_times.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0)) & (
        arrival_times.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0))
    time_window_feasibility = within_time_window.float()

    # Capacity checks
    load_after_delivery = current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)
    potential_loads_after_pickup = current_load_open.unsqueeze(1) + pickup_node_demands.unsqueeze(0)

    delivery_capacity_check = (load_after_delivery >= 0).float()
    pickup_capacity_check = (potential_loads_after_pickup >= 0).float()

    # Duration limits
    duration_check = (current_length.unsqueeze(1) >= current_distance_matrix).float()

    # Combine indicators to form a final score
    feasibility_indicator = delivery_feasibility * pickup_feasibility * time_window_feasibility * delivery_capacity_check * pickup_capacity_check * duration_check
    distance_inv = 1 / (current_distance_matrix + 1e-5)  # Avoid division by zero
    normalized_distance_scores = distance_inv * feasibility_indicator

    # Apply randomness to improve exploration
    randomness_factor = torch.rand((num_trajectories, num_nodes), device=current_distance_matrix.device) * 0.1
    heuristic_scores = normalized_distance_scores + randomness_factor

    return heuristic_scores
```
