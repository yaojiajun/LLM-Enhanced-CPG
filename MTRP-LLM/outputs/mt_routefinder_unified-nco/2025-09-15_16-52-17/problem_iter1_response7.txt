```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Constants
    INF = float('inf')
    
    # Compute open routes score based on remaining capacities and time window feasibility
    remaining_capacity = current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)
    valid_delivery_capacity = (remaining_capacity >= 0).float()  # 1 if feasible, 0 otherwise

    # Assess time window feasibility
    valid_time_windows = (arrival_times.unsqueeze(1) + current_distance_matrix >= time_windows[:, 0].unsqueeze(0)) & \
                         (arrival_times.unsqueeze(1) + current_distance_matrix <= time_windows[:, 1].unsqueeze(0))
    
    wait_time_penalty = torch.where(valid_time_windows, 0, 
                                    (arrival_times.unsqueeze(1) + current_distance_matrix - time_windows[:, 1].unsqueeze(0)) ** 2)

    # Consider backhaul flexibility
    backhaul_capacity = current_load_open.unsqueeze(1) - pickup_node_demands.unsqueeze(0)
    valid_backhaul_capacity = (backhaul_capacity >= 0).float()

    # Determine the duration limits
    valid_length = (current_length.unsqueeze(1) >= current_distance_matrix).float()

    # Aggregating the scores
    scores = (valid_delivery_capacity * valid_time_windows.float() * valid_length *
              1 / (current_distance_matrix + 1e-6) - wait_time_penalty.sum(dim=0))

    # Add randomness to avoid local optimus
    randomness_component = torch.randn_like(scores) * 0.01

    # Final heuristic score matrix
    heuristic_scores = scores + randomness_component

    return heuristic_scores
```
