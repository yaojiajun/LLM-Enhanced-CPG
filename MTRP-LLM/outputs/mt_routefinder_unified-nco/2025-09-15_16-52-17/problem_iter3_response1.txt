```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Calculate feasibility based on load, length, and time window constraints
    load_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    time_feasibility = ((arrival_times + current_distance_matrix) <= time_windows[:, 1].unsqueeze(0)).float()
    length_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix.sum(dim=1)).float()
    
    # Create a combined feasibility matrix
    feasibility_matrix = load_feasibility * time_feasibility * length_feasibility
    
    # Generate random scores to increase exploration
    exploration_scores = torch.rand_like(current_distance_matrix) * feasibility_matrix
    
    # Compute penalties based on historical sampling (Adaptive mechanism)
    penalty_load = (torch.clamp(delivery_node_demands.unsqueeze(0) - current_load.unsqueeze(1), min=0) * 0.5) * feasibility_matrix
    penalty_time = (torch.clamp(arrival_times + current_distance_matrix - time_windows[:, 1].unsqueeze(0), min=0) * 0.5) * feasibility_matrix
    penalty_scores = penalty_load + penalty_time
    
    # Combine exploration scores with penalties to generate heuristic scores
    heuristic_scores = exploration_scores - penalty_scores
    
    # Introduce enhanced randomness
    randomness_factor = (torch.rand_like(heuristic_scores) * 0.1) * feasibility_matrix
    heuristic_scores += randomness_factor
    
    return heuristic_scores
```
