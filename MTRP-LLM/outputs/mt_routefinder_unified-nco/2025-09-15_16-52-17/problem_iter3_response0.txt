```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor,
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor,
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Initialize heuristic scores matrix
    pomo_size, N_plus_1 = current_distance_matrix.shape
    heuristic_scores = torch.zeros((pomo_size, N_plus_1), device=current_distance_matrix.device)

    # Compute feasible visits based on demand and capacity constraints
    delivery_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0).expand(pomo_size, -1)) & \
                           (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0).expand(pomo_size, -1))

    # Calculate the waiting times based on time windows
    current_time = arrival_times + current_distance_matrix  # Estimated arrival at each node
    time_window_violation = (current_time < time_windows[:, 0].unsqueeze(0)) | (current_time > time_windows[:, 1].unsqueeze(0))
    
    # Heuristic score calculation
    base_scores = -current_distance_matrix * delivery_feasibility.float()  # Negative distances favor closer nodes
    penalty_factor = 0.1 * time_window_violation.float()  # Introduce penalties for violating time windows
    heuristic_scores = base_scores - penalty_factor

    # Adaptive penalties based on prior feasibility
    adaptive_penalty = torch.where(delivery_feasibility, torch.zeros_like(heuristic_scores), torch.full_like(heuristic_scores, 1.0))
    heuristic_scores -= adaptive_penalty * 0.5

    # Add randomness to enhance exploration
    random_scores = torch.rand_like(heuristic_scores) * 0.1  # Small random values for diversity
    heuristic_scores += random_scores
    
    return heuristic_scores
```
