```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor,
                  delivery_node_demands: torch.Tensor,
                  current_load: torch.Tensor,
                  delivery_node_demands_open: torch.Tensor,
                  current_load_open: torch.Tensor,
                  time_windows: torch.Tensor,
                  arrival_times: torch.Tensor,
                  pickup_node_demands: torch.Tensor,
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Calculate feasibility based on capacity, time windows, and remaining length constraints
    feasible_delivery = (current_load.unsqueeze(-1) >= delivery_node_demands[:, None]) & \
                        (current_length.unsqueeze(-1) >= current_distance_matrix) & \
                        (arrival_times < time_windows[:, None, 1]) & \
                        (arrival_times + current_distance_matrix <= time_windows[:, None, 1])
    
    feasible_pickup = (current_load_open.unsqueeze(-1) >= pickup_node_demands[:, None]) & \
                      (current_length.unsqueeze(-1) >= current_distance_matrix) & \
                      (arrival_times < time_windows[:, None, 1]) & \
                      (arrival_times + current_distance_matrix <= time_windows[:, None, 1])
    
    # Calculate heuristic scores based on distance and fulfillability
    distance_cost = current_distance_matrix * (1 - feasible_delivery.float()) - 1e5 * (1 - feasible_pickup.float())
    
    # Introduce randomness to scores to mitigate local optima
    noise = torch.rand_like(distance_cost) * 0.1 - 0.05  # small random fluctuations
    score_matrix = distance_cost + noise
    
    # Adjust scores to make feasible options more favorable
    score_matrix[feasible_delivery] += 100  # Bonus for feasible deliveries
    score_matrix[feasible_pickup] += 50   # Less bonus for feasible pickups
    
    return score_matrix
```
