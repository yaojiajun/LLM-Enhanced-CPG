```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    # Initialize heuristic score matrix
    score_matrix = torch.zeros_like(current_distance_matrix)

    # Determine load feasibility for delivery nodes
    feasible_deployments = (delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1)) & \
                           (delivery_node_demands_open.unsqueeze(0) <= current_load_open.unsqueeze(1))

    # Determine timing feasibility
    current_time = arrival_times.unsqueeze(1) + current_distance_matrix
    within_time_window = (current_time >= time_windows[:, 0].unsqueeze(0)) & \
                         (current_time <= time_windows[:, 1].unsqueeze(0))

    # Determine length feasibility
    length_constraint = current_length.unsqueeze(1) >= current_distance_matrix

    # Combine feasibility checks
    feasibility_mask = feasible_deployments & within_time_window & length_constraint

    # Scoring constraints where feasible
    score_matrix[feasibility_mask] = (1.0 / (1.0 + current_distance_matrix[feasibility_mask])) * 1000.0

    # Introducing an enhanced randomness component Uniform[0, 1)
    randomness = torch.rand_like(score_matrix) * 0.1
    score_matrix += randomness

    # General high penalties for unfeasible edges
    score_matrix[~feasibility_mask] = -float('inf')

    return score_matrix
```
