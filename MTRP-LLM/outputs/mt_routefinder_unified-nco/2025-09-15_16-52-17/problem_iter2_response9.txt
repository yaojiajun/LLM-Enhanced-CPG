```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Incorporate problem-specific constraints and penalize infeasible nodes heavily
    # Calculate heuristic score matrix based on constraints and randomness
    # For example, penalize nodes with demands exceeding the remaining load capacity
    penalty_demand = torch.clamp(delivery_node_demands - current_load, min=0)
    
    # Penalize nodes outside time windows by a factor based on the delay
    delay_penalty = torch.max(arrival_times[:, 1:] - time_windows[:, 1].view(-1, 1), torch.zeros_like(arrival_times[:, 1:]) - 1)
    
    # Penalize nodes with pickup demand exceeding capacity
    penalty_pickup = torch.clamp(pickup_node_demands - current_load, min=0)
    
    # Penalize nodes if adding them exceeds the route duration budget
    penalty_length = torch.clamp(current_distance_matrix + current_length.view(-1, 1) - current_distance_matrix[:, 0].view(-1, 1) - current_length.view(-1, 1), min=0)
    
    # Combine penalties into a heuristic score matrix
    heuristic_scores = -0.5 * penalty_demand - 0.5 * delay_penalty - 0.5 * penalty_pickup - 0.5 * penalty_length + torch.rand_like(current_distance_matrix)

    return heuristic_scores
```
