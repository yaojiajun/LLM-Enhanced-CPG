```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Constants
    very_large_negative = -1e10
    very_large_positive = 1e10

    # Initialize the heuristic score matrix
    heuristic_scores = torch.zeros_like(current_distance_matrix)

    # Delivery feasibility: check if current load allows visiting node
    load_capacity_met = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    load_capacity_met_open = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()
    
    # Time window validity: checking if nodes can be visited within time windows
    earliest_arrival = arrival_times.unsqueeze(2) + current_distance_matrix.unsqueeze(1)
    time_window_validity = ((earliest_arrival >= time_windows[:, 0].unsqueeze(0).unsqueeze(0)).float() & 
                             (earliest_arrival <= time_windows[:, 1].unsqueeze(0).unsqueeze(0)).float())

    # Route length feasibility: comparing with the remaining length budget
    length_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix).float()

    # Combine feasibility checks
    feasibility_mask = load_capacity_met * load_capacity_met_open * time_window_validity * length_feasibility
    
    # Assign positive scores for feasible and promising edges
    heuristic_scores += feasibility_mask * (very_large_positive / (current_distance_matrix + 1e-6))
    
    # Assign negative scores for infeasibility
    heuristic_scores += (1 - feasibility_mask) * very_large_negative

    # Enhancing randomness while keeping high scores
    random_variation = torch.rand_like(heuristic_scores) * 1e-3
    heuristic_scores += random_variation * feasibility_mask

    return heuristic_scores
```
