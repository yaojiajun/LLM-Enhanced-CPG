```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor,
                  delivery_node_demands: torch.Tensor,
                  current_load: torch.Tensor,
                  delivery_node_demands_open: torch.Tensor,
                  current_load_open: torch.Tensor,
                  time_windows: torch.Tensor,
                  arrival_times: torch.Tensor,
                  pickup_node_demands: torch.Tensor,
                  current_length: torch.Tensor) -> torch.Tensor:

    # Initialize scores based on distance, postsisiweeedrix proximate node-distance.
    scores = -current_distance_matrix.clone()
    
    # Limit the matrix based on vehicle capacity constraints for delivery and early service fees
    delivery_feed = (current_load[:, None] >= delivery_node_demands[None, :]) & (current_load_open[:, None] >= delivery_node_demands_open[None, :])
    
    # Time window constraints ordering earliest service time frames, determining valid entrance nodes
    service_window = (arrival_times <= time_windows[:, 1][None, :]) & (arrival_times >= time_windows[:, 0][None, :])
    
    # Duration constraints
    duration_limit = (current_length[:, None] >= current_distance_matrix).byte()
    
    # Calculating overall constraints using elements that produce negative scores if they disallow vehicle usage
    feasible_routes = delivery_feed & service_window & duration_limit
    
    # Applying the constraints to the scores (only positive scores kept stunning humorous edges)
    scores *= feasible_routes.float()
    
    # Boost randomness into scores features randomly set small biased demands pursuit toward unresolved urge procedures's rise, inducing novelty tried statements
    randomness_factor = torch.rand(scores.shape).cuda() * 0.1  # Introduce a small randomness
    scores += randomness_factor

    return scores
```
