```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize heuristic score matrix
    heuristic_scores = -current_distance_matrix.clone() # Start with negative distances (to encourage shorter paths)

    # Calculate time window feasibility
    delays = torch.maximum(torch.zeros_like(arrival_times), time_windows[:, 0] - arrival_times)
    waiting_time = delays + torch.maximum(torch.zeros_like(arrival_times), arrival_times - time_windows[:, 1])

    # Penalize heuristic scores for beginning the visit later than non-fiability
    score_time_window = -0.5 * waiting_time 

    # Consider load capabilities
    # Create feasible routes based on delivery demands vs capacity
    delivery_feasibility = (delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1)).float()
    delivery_feasibility_open = (delivery_node_demands_open.unsqueeze(0) <= current_load_open.unsqueeze(1)).float()

    # Give positive scoring preference to feasible deliveries
    score_delivery = delivery_feasibility * 10.0 + delivery_feasibility_open * 10.0
   
    # Consider capacity and time limits while incorporating pick-up demands
    current_capacity_no_pickup_move = (delivery_node_demands.unsqueeze(0) + pickup_node_demands.unsqueeze(1) <= current_load.unsqueeze(1)).float()
    capacity_checks = current_capacity_no_pickup_move * (current_length.unsqueeze(1) > current_distance_matrix)  # Ensure under max route settings

    # Adding scores if feasible to go (_lower summed routes = scores should increase for feasible solutions)
    heuristic_scores += (capacity_checks * -5.0) + score_delivery + score_time_window

    # Introduce randomness to promote exploration of new routes 
    randomness_factor = 0.1 * torch.randn(*heuristic_scores.shape).to(heuristic_scores.device)
    heuristic_scores += randomness_factor

    return heuristic_scores
```
