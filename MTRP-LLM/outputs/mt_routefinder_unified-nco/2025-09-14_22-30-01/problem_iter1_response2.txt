```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor,
                  current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor,
                  current_load_open: torch.Tensor, time_windows: torch.Tensor,
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor,
                  current_length: torch.Tensor) -> torch.Tensor:

    num_trajectories, num_nodes = current_distance_matrix.shape
    
    # Initialize heuristic score matrix
    heuristic_scores = torch.zeros((num_trajectories, num_nodes), device=current_distance_matrix.device)
    
    # Calculate vehicle remaining capacities availability for delivery and pickups
    sufficient_load_deliveries = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    sufficient_load_pickups = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0)).float()
    
    # Time window satisfaction (accounting for waiting times)
    earliest_arrivals = arrival_times + current_distance_matrix
    valid_time_windows = ((earliest_arrivals >= time_windows[:, 0].unsqueeze(0)) &
                          (earliest_arrivals <= time_windows[:, 1].unsqueeze(0))).float()
    
    # Feasible routes detection combining both delivery and pickups
    feasible_routes = sufficient_load_deliveries * valid_time_windows * \
                      sufficient_load_pickups * (current_length.unsqueeze(1) >= current_distance_matrix)
    
    # Compute random factor to enhance exploration
    random_factor = torch.rand_like(heuristic_scores) * 0.5
    aggregated_feasibility = feasible_routes + random_factor

    # Compute the heuristic score: penalizing long distances and rewarding feasible routes
    heuristic_scores = (aggregated_feasibility * (1.0 / (1.0 + current_distance_matrix)))

    # Combine with distance to reduce impact of undesirable edges (negative scores)
    heuristic_scores -= (1.0 - feasible_routes) * current_distance_matrix / current_distance_matrix.max()

    # Final adjustment to encourage exploration while balancing feasible routes
    heuristic_scores *= (1 + random_factor)    

    return heuristic_scores
```
