```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor,
                  delivery_node_demands: torch.Tensor,
                  current_load: torch.Tensor,
                  delivery_node_demands_open: torch.Tensor,
                  current_load_open: torch.Tensor,
                  time_windows: torch.Tensor,
                  arrival_times: torch.Tensor,
                  pickup_node_demands: torch.Tensor,
                  current_length: torch.Tensor) -> torch.Tensor:

    # Initialize the heuristic score matrix with zeros
    heuristic_scores = torch.zeros_like(current_distance_matrix)
    
    # Calculate boolean masks for feasibility based on capacity
    can_deliver = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0))
    can_pickup = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0))

    # Incorporating time window feasibility
    arrival_time_check = (arrival_times.unsqueeze(1) + current_distance_matrix <= time_windows[:, 1].unsqueeze(0)) & \
                         (arrival_times.unsqueeze(1) + current_distance_matrix >= time_windows[:, 0].unsqueeze(0))
    feasible_edges = can_deliver & arrival_time_check

    # Reversing the conditions for pickups checks
    pickup_feasible_edges = can_pickup & arrival_time_check

    # Calculate heuristic scores with added penalties
    penalty_factor = 1e2
    distance_penalty = penalty_factor * (~feasible_edges) * current_distance_matrix
    heuristic_scores -= distance_penalty

    # Add pickup feasibility into scoring
    scores_for_pickup = 10 * pickup_feasible_edges.float()  # Assign positive scores for feasible pickups
    heuristic_scores += scores_for_pickup

    # Randomness influence to escape local optima
    randomness = torch.rand_like(heuristic_scores) * 0.5  # Add some stochasticity
    heuristic_scores += randomness

    return heuristic_scores
```
