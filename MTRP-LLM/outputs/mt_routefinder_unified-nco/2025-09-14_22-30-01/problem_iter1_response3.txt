```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Shape definitions
    pomo_size, N_plus_1 = current_distance_matrix.shape
    N = N_plus_1 - 1
    
    # Initialize score matrix
    score_matrix = torch.zeros_like(current_distance_matrix)

    # Constraints evaluations
    feasible_remainder = (delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1)).float() * 
                         (delivery_node_demands_open.unsqueeze(0) <= current_load_open.unsqueeze(1)).float() *
                         (current_length.unsqueeze(1) >= current_distance_matrix).float()
    
    time_valid = (arrival_times + current_distance_matrix >= time_windows[:, 0].unsqueeze(0)).float() * \
                 (arrival_times + current_distance_matrix <= time_windows[:, 1].unsqueeze(0)).float()

    # Adjust scores for feasibility - promising edges
    score_matrix += feasible_remainder * time_valid * (1 - current_distance_matrix / current_distance_matrix.max())
    
    # Consider time window penalties (to increase overall efficiency)
    waiting_time = torch.clamp(time_windows[:, 0].unsqueeze(0) - arrival_times - current_distance_matrix, min=0)
    score_matrix -= waiting_time * 0.1  # Apply penalty for potential waiting times

    # Randomness enhancement: modify scores with a noise factor to promote exploration
    randomness_factor = torch.rand_like(score_matrix) * 0.05
    score_matrix += randomness_factor
    
    # Transform scores into fatigue measure (adding negative aspects)
    fatigue_penalty = 1.5 * (current_load < 0).float()
    score_matrix -= fatigue_penalty

    # Return the final score matrix
    return score_matrix
```
