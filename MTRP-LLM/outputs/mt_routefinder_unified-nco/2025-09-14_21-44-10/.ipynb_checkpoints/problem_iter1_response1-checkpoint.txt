```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize scores with negative infinity to handle undesirable conditions.
    score_matrix = -torch.inf * torch.ones_like(current_distance_matrix)

    # Check capacity constraints for deliveries
    delivery_capacity_mask = delivery_node_demands.unsqueeze(0) <= current_load.unsqueeze(1)
    delivery_capacity_mask_open = delivery_node_demands_open.unsqueeze(0) <= current_load_open.unsqueeze(1)

    # Check length constraints
    length_mask = current_length.unsqueeze(1) >= current_distance_matrix
    length_mask_open = current_length.unsqueeze(1) >= current_distance_matrix

    # Check time window feasibility
    current_time = arrival_times.unsqueeze(1) + current_distance_matrix
    time_window_mask = (current_time >= time_windows[:, 0]) & (current_time <= time_windows[:, 1])

    # Creating a feasible mask combining all constraints
    feasible_mask = delivery_capacity_mask & length_mask & time_window_mask
    feasible_mask_open = delivery_capacity_mask_open & length_mask_open & time_window_mask
    
    # Assign scores for feasible deliveries: lower distance becomes higher score
    score_matrix[feasible_mask] = -current_distance_matrix[feasible_mask]  # Negative distance for minimization task

    # Apply randomness to improve exploration in local optima    
    random_factor = torch.randn_like(score_matrix) * 0.01  # Small random noise
    score_matrix += random_factor

    # Higher preference for pickup nodes if they're open for sampling
    pickup_score_addition = pickup_node_demands.unsqueeze(0) > 0
    score_matrix[pickup_score_addition] += 1  # Boost score for nodes where pickup is valid

    # Normalize scores to enhance performance as the last step
    max_scores = score_matrix.max(dim=-1, keepdim=True)[0]
    normalized_scores = score_matrix - max_scores

    return normalized_scores
```
