```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Parameters
    num_nodes = current_distance_matrix.size(1)  # number of nodes including depot
    pono_size = current_distance_matrix.size(0)  # number of vehicles/path options
    
    # Initialize heuristic score matrix
    heuristic_scores = torch.full((pono_size, num_nodes), -float('inf'))
    
    # Ensure we don't loop back to the depot with open routes
    heuristic_scores[:, 0] = float('-inf')  # Depot has no heuristic
        
    # Checking against constraints
    can_deliver = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0))
    can_pickup = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0))
    within_time_window = (arrival_times.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0)) & (arrival_times.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0))
    within_length = (current_length.unsqueeze(1) >= current_distance_matrix)

    # Building heuristic score based on dual criteria `distance` and `capacity`
    distance_scores = 1 / (current_distance_matrix + 1e-6)  # To prevent division by zero
    capacity_scores_deliver = torch.where(can_deliver, distance_scores, torch.tensor(-float('inf')))
    capacity_scores_pickup = torch.where(can_pickup, distance_scores, torch.tensor(-float('inf')))

    # Combine criteria under appropriate constraints for delivery & pickup
    heuristic_scores = capacity_scores_deliver * within_time_window + capacity_scores_pickup * within_length
    
    # Enhance randomness in heuristic assignments
    randomness_matrix = torch.rand_like(heuristic_scores) * 0.1
    heuristic_scores += randomness_matrix
    
    # Final score normalization
    heuristic_scores = (heuristic_scores - heuristic_scores.mean(dim=1, keepdim=True)) / (heuristic_scores.std(dim=1, keepdim=True) + 1e-6)
    
    return heuristic_scores
```
