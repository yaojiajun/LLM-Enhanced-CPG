```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor,
                  delivery_node_demands: torch.Tensor,
                  current_load: torch.Tensor,
                  delivery_node_demands_open: torch.Tensor,
                  current_load_open: torch.Tensor,
                  time_windows: torch.Tensor,
                  arrival_times: torch.Tensor,
                  pickup_node_demands: torch.Tensor,
                  current_length: torch.Tensor) -> torch.Tensor:

    # Total number of nodes and trajectories
    pomo_size, num_nodes = arrival_times.shape[0], arrival_times.shape[1]

    # Initialize the score matrix with zeros
    heuristic_scores = torch.zeros((pomo_size, num_nodes), device=current_distance_matrix.device)

    # Check feasibility against vehicle constraints (capacity, time windows, length)
    
    # The usable load (delivering volume) before visiting each node
    inventory_load = current_load[:, None] - delivery_node_demands[None, :] 
    capacity_check = inventory_load >= 0

    # For open routes
    open_inventory_load = current_load_open[:, None] - delivery_node_demands_open[None, :]
    open_capacity_check = open_inventory_load >= 0

    # Ensure capacity opening and depending on the pickup demands
    pickup_capacity_check = (current_load[:, None] + pickup_node_demands[None, :]) <= current_load.max()
    
    # Scalar adjustments by distance and wait times using time windows
    wait_time = torch.maximum(torch.zeros_like(arrival_times), (time_windows[:, 0] - arrival_times))
    
    # Prepare temporal considerations in scores - penalties for arrival than time window permits
    arrival_time_penalty = ((arrival_times >= time_windows[:, 1][:, None]).float() * 10)
    
    # Combine shifts based on travel distance, wait time, and feasible conditions
    valid_paths = capacity_check & open_capacity_check & pickup_capacity_check

    # Distance scores penalized weight
    distance_scores = (current_length[:, None] / (current_distance_matrix + 1e-5)) * valid_paths.float()
    
    # Wait and time penalty integration to the heuristic scores
    heuristic_scores = (1 / (1 + distance_scores)) - wait_time[:, None] - arrival_time_penalty

    # Introducing randomness term to avoid sticking in local optima
    randomness = torch.rand_like(heuristic_scores)
    heuristic_scores += 0.05 * randomness

    return heuristic_scores
```
