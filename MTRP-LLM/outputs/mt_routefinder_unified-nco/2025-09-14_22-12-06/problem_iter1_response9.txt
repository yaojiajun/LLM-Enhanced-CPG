```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Initialize heuristic score matrix
    score_matrix = torch.zeros_like(current_distance_matrix)

    # Calculate satisfied demand by feasibility
    satisfied_demand = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    satisfied_demand_open = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()
    feasible_delivery = satisfied_demand * satisfied_demand_open

    # Calculate temporal feasibility based on time windows
    arrival_not_before = (arrival_times + current_distance_matrix) >= time_windows[:, 0].unsqueeze(0)
    arrival_not_after = (arrival_times + current_distance_matrix) <= time_windows[:, 1].unsqueeze(0)
    feasible_time = arrival_not_before * arrival_not_after

    # Calculate fulfillment potential considering pickups 
    satisfied_pickup = (current_load.unsqueeze(1) + pickup_node_demands.unsqueeze(0)) <= delivery_node_demands.unsqueeze(1).max(dim=1, keepdim=True)[0]
    feasible_pickup = satisfied_pickup.float() + (current_load_open.unsqueeze(1) + pickup_node_demands.unsqueeze(0)) <= delivery_node_demands_open.unsqueeze(1).max(dim=1, keepdim=True)[0]

    # Combine feasibility for routing ideally - Favors nodes that meet all constraints 
    overall_feasibility = feasible_delivery * feasible_time * feasible_pickup

    # Negative rewards for nodes that are infeasible
    score_matrix += overall_feasibility * (-current_distance_matrix)

    # Penalties for exceeding current load and length budget
    load_penalty = (current_load.unsqueeze(1) + delivery_node_demands.unsqueeze(0) > current_load.unsqueeze(0).max(dim=1, keepdim=True)[0]).float() * 1e4
    length_penalty = (current_length.unsqueeze(1) < current_distance_matrix).float() * 1e4
    
    # Update score matrix using penalties
    score_matrix -= (load_penalty + length_penalty)

    # Introduce enhanced randomness to avoid local optima
    randomness = torch.rand_like(score_matrix) * 0.1
    score_matrix += randomness

    return score_matrix
```
