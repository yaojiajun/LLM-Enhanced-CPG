```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor,
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor,
                  time_windows: torch.Tensor, arrival_times: torch.Tensor,
                  pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Initialize the heuristic score matrix
    score_matrix = torch.zeros_like(current_distance_matrix)

    # Compute available capacity for delivery and pickup
    available_capacity = current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)
    available_capacity_open = current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)
    
    # Compute time window feasibility
    arrival_time_window = (arrival_times + current_distance_matrix <= time_windows[:, 1].unsqueeze(0)) \
                          & (arrival_times + current_distance_matrix >= time_windows[:, 0].unsqueeze(0))

    # Calculate penalties for exceeding load or time constraints
    overflow_penalty = (current_load.unsqueeze(1) + delivery_node_demands.unsqueeze(0) > 100).float() * -1
    overflow_penalty_open = (current_load_open.unsqueeze(1) + delivery_node_demands_open.unsqueeze(0) > 100).float() * -1

    # Duration limits
    duration_constraint = (current_length.unsqueeze(1) >= current_distance_matrix).float()
    
    # Compute heuristic scores
    score_matrix += (available_capacity.float() * available_capacity_open.float() * arrival_time_window.float() +
                     duration_constraint - abs(overflow_penalty) - abs(overflow_penalty_open))

    # Introduce randomness to avoid local optima
    noise = torch.rand_like(score_matrix) * 0.1
    score_matrix += noise

    return score_matrix
```
