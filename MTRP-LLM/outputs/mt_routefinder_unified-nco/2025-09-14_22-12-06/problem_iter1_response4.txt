```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Initialize heuristic score matrix
    score_matrix = torch.zeros_like(current_distance_matrix)

    # Get the number of nodes and the size of current path optimization matrix
    size = current_distance_matrix.shape

    # Compute feasible delivery nodes
    feasible_delivery_mask = (current_load.view(-1, 1) >= delivery_node_demands.view(1, -1)) & (
        arrival_times[:, 1:] <= time_windows[1, 1]) & (arrival_times[:, 1:] >= time_windows[1, 0]) & (
        current_length.view(-1, 1) >= current_distance_matrix[:, 1:])

    # Compute scores based on the inverse of distance for promising routes
    distance_scores = torch.where(feasible_delivery_mask, 1 / (1 + current_distance_matrix[:, 1:]), torch.tensor(0.0, device=current_distance_matrix.device))
    
    # Incorporate bonuses for early servicing (lean towards min early arrival)
    early_service_bonus = torch.where(
        feasible_delivery_mask,
        torch.clamp(time_windows[1:, 0] - arrival_times[:, 1:], min=0) * 0.1,  # e.g., penalty if too late
        torch.tensor(0.0, device=current_distance_matrix.device)
    )

    # Aggregate scores
    route_scores = distance_scores + early_service_bonus

    # Add randomness to avoid local optima - fine-tune randomness weight depending on need
    random_factor = torch.rand(size[0], size[1] - 1, device=current_distance_matrix.device) * 0.01 
    extended_random_factor_matrix = torch.cat((torch.zeros(size[0], 1, device=current_distance_matrix.device), random_factor), dim=1)
    
    # Combine scores with randomness
    score_matrix = route_scores + extended_random_factor_matrix

    # Handle backhauls
    feasible_backhaul_mask = (current_load_open.view(-1, 1) >= pickup_node_demands.view(1, -1)) & (current_length.view(-1, 1) >= current_distance_matrix[:, 1:])
    backhaul_scores = torch.where(feasible_backhaul_mask, 1 / (1 + current_distance_matrix[:, 1:]), torch.tensor(0.0, device=current_distance_matrix.device))
    
    # Incorporate backhaul scores into final score_matrix
    score_matrix += backhaul_scores

    return score_matrix
```
