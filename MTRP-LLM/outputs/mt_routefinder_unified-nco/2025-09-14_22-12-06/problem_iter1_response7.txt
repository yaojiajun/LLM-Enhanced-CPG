```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Calculate remaining capacities for delivery and pickup
    valid_delivery_mask = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0))  # Shape: (pomo_size, N+1)
    valid_pickup_mask = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0))  # Shape: (pomo_size, N+1)

    # Calculate time window feasibility
    arrival_times_window = (arrival_times.unsqueeze(2) >= time_windows[:, 0]) & (arrival_times.unsqueeze(2) <= time_windows[:, 1])
    
    # Incorporate duration limits
    feasible_time_windows = arrival_times_window & (current_length.unsqueeze(1) >= current_distance_matrix.unsqueeze(0))

    # Create a heuristic score based on distances filtered through capacity and time windows
    heuristic_scores = torch.zeros_like(current_distance_matrix)  # Shape: (pomo_size, N+1)
    
    # Scoring scale factors could adjust importance: shorter distance is better, adaptable to prevent local minima
    distance_scores = -current_distance_matrix.detach()
    
    # Apply masks to scores
    authorized_trips = valid_delivery_mask & valid_pickup_mask & feasible_time_windows
    heuristic_scores[authorized_trips] = distance_scores[authorized_trips]
    
    # Introduce randomness in scoring for local optimum avoidance
    randomness_factor = torch.rand_like(heuristic_scores) * 0.1  # Adding a bit of randomness
    heuristic_scores += randomness_factor
    
    # Normalize scores to ensure numerical stability
    normalized_scores = (heuristic_scores - heuristic_scores.min(dim=1, keepdim=True).values) / \
                        (heuristic_scores.max(dim=1, keepdim=True).values - heuristic_scores.min(dim=1, keepdim=True).values + 1e-8)
    
    return normalized_scores
```
