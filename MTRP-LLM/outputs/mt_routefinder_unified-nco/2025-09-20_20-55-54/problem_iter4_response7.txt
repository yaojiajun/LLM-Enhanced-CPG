```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor,
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor,
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Introduce small epsilon for numerical stability
    epsilon = 1e-8

    # Compute remaining capacities considering both delivery and pickup demands
    feasible_delivery = (current_load.unsqueeze(-1) >= delivery_node_demands.unsqueeze(0)).float()
    feasible_pickup = (current_load_open.unsqueeze(-1) >= pickup_node_demands.unsqueeze(0)).float()

    # Create a mask for time window constraints
    time_mask = (arrival_times.unsqueeze(-1) + current_distance_matrix <= time_windows[:, 1].unsqueeze(0)).float()
    time_mask *= (arrival_times.unsqueeze(-1) + current_distance_matrix >= time_windows[:, 0].unsqueeze(0)).float()

    # Combine masks for feasible nodes
    feasibility = feasible_delivery * feasible_pickup * time_mask

    # Calculate scores based on distance while keeping feasibility in mind
    normalized_distances = 1 / (current_distance_matrix + epsilon)
    heuristic_scores = feasibility * normalized_distances

    # Introduce controlled randomness to enhance exploration
    exploration_noise = torch.randn_like(heuristic_scores) * 0.1
    heuristic_scores += exploration_noise

    # Clamp scores to finite values
    heuristic_scores = torch.clamp(heuristic_scores, min=-1e10, max=1e10)

    return heuristic_scores
```
