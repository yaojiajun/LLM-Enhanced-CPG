```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Feature scaling
    eps = 1e-8
    scaled_distance = current_distance_matrix / (current_distance_matrix.max() + eps)
    scaled_arrival_times = arrival_times / (arrival_times.max(dim=1, keepdim=True)[0] + eps)
    scaled_time_windows = time_windows / (time_windows.max() + eps)

    # Integrate constraints into scoring
    load_ratio = current_load.unsqueeze(2) / (delivery_node_demands.unsqueeze(0) + eps)
    open_load_ratio = current_load_open.unsqueeze(2) / (delivery_node_demands_open.unsqueeze(0) + eps)
    duration_ratio = current_length.unsqueeze(2) / (current_length.sum(dim=1, keepdim=True) + eps)

    # Construct heuristic scores using a combination of constraints
    heuristic_scores = scaled_distance + scaled_arrival_times + scaled_time_windows - load_ratio + open_load_ratio - duration_ratio

    # Add controlled randomness
    random_noise = torch.rand_like(heuristic_scores) * 0.1  # Adjust randomness level accordingly
    heuristic_scores += random_noise

    return heuristic_scores
```
