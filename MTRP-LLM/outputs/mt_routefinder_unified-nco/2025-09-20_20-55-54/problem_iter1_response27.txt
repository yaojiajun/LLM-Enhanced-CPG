```python
import torch
import torch.nn.functional as F

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Normalize input tensors
    current_distance_matrix_norm = F.normalize(current_distance_matrix, p=2, dim=1)
    delivery_node_demands_norm = F.normalize(delivery_node_demands.unsqueeze(-1), p=2, dim=0).squeeze()
    current_load_norm = F.normalize(current_load.unsqueeze(-1), p=2, dim=1).squeeze()
    delivery_node_demands_open_norm = F.normalize(delivery_node_demands_open.unsqueeze(-1), p=2, dim=0).squeeze()
    current_load_open_norm = F.normalize(current_load_open.unsqueeze(-1), p=2, dim=1).squeeze()

    # Add small epsilon for numerical stability
    epsilon = 1e-8
    
    # Calculate heuristics scores
    heuristic_scores = (current_distance_matrix_norm / (delivery_node_demands_norm + epsilon)) + (delivery_node_demands_open_norm / (current_load_norm + epsilon)) - (current_load_open_norm / (current_load_norm + epsilon))
    
    # Introduce controlled randomness
    randomness = torch.rand(heuristic_scores.size()) * 0.1  # Adjust weight of randomness as needed
    heuristic_scores += randomness

    # Clamp scores and mask invalid values
    heuristic_scores = torch.where(torch.isnan(heuristic_scores), torch.zeros_like(heuristic_scores), heuristic_scores)
    heuristic_scores = torch.clamp(heuristic_scores, -1e6, 1e6)

    return heuristic_scores
```
