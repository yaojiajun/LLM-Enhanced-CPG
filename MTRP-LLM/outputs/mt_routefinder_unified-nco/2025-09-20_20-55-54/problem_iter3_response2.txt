```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Feature scaling and normalization
    distance_norm = current_distance_matrix / (current_distance_matrix.max() + 1e-8)
    demands_norm = delivery_node_demands / (delivery_node_demands.max() + 1e-8)
    load_norm = current_load / (current_load.max() + 1e-8)
    
    # Incorporate problem-specific constraints
    time_window_range = time_windows[:, 1] - time_windows[:, 0]
    time_window_ratio = time_window_range / (time_window_range.max() + 1e-8)
    
    load_demand_ratio = delivery_node_demands / (current_load + 1e-8)
    open_load_demand_ratio = delivery_node_demands_open / (current_load_open + 1e-8)
    
    # Introduce randomness in scoring
    heuristic_scores = distance_norm + demands_norm - load_norm + time_window_ratio - load_demand_ratio + open_load_demand_ratio + torch.rand_like(current_distance_matrix) * 0.1
    
    return heuristic_scores
```
