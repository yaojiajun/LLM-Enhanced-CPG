```python
import torch
import torch.nn.functional as F
import torch.distributions as tdist

def heuristics_v2(current_distance_matrix, delivery_node_demands, current_load, delivery_node_demands_open, current_load_open, time_windows, arrival_times, pickup_node_demands, current_length):
    # Calculate distance-based scores
    distance_scores = -current_distance_matrix

    # Capacity check scores
    capacity_check = F.relu(-current_load + delivery_node_demands.unsqueeze(0))
    capacity_check_open = F.relu(-current_load_open + delivery_node_demands_open.unsqueeze(0))
    capacity_scores = torch.min(capacity_check, capacity_check_open)

    # Time window scores
    time_window_lower = F.relu((time_windows[:, 0] - arrival_times) + 1e-8)  # Adding epsilon for stability
    time_window_upper = F.relu((arrival_times - time_windows[:, 1]) + 1e-8)
    time_window_scores = -torch.min(time_window_lower, time_window_upper)

    # Duration threshold scores
    duration_diff = -current_length.unsqueeze(1) + current_distance_matrix
    duration_scores = F.relu(1 - F.relu(duration_diff) / (1e-8 + duration_diff))

    # Introduce random noise to promote exploration
    noise = tdist.Cauchy(0, 0.5).sample(distance_scores.shape).to(current_distance_matrix.device)

    # Combine different scores and add noise
    heuristic_scores = 0.4 * distance_scores + 0.2 * capacity_scores + 0.2 * time_window_scores + 0.2 * duration_scores + noise

    # Ensure finite and return
    return torch.clamp(heuristic_scores, -1e6, 1e6)
```  
