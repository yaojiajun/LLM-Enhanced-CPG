```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Modify the way distance-based heuristic score is computed
    # Heuristic Distance Score: Adjusted inverse distance as a proxy for edge attractiveness 
    inverted_distances = 1.0 / current_distance_matrix.clamp(min=1.0)
    distance_scores = inverted_distances - torch.min(inverted_distances)

    # Compute the demand-based heuristic score matrix with emphasis on high-demand nodes and enhanced randomness
    demand_scores = ((delivery_node_demands * 2).unsqueeze(0) - current_load.unsqueeze(1)) * 0.6 + (torch.max(delivery_node_demands) / 3) + torch.randn_like(current_distance_matrix) * 0.4

    # Composite score includes distance and demand components with added noise for exploration
    composite_scores = distance_scores + demand_scores

    return composite_scores

```
