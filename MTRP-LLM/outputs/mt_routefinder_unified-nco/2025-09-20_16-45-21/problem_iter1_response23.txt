```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    epsilon = 1e-8
    
    # Initial heuristic scores based on distance favors nearest neighbor strategy
    distance_score = -current_distance_matrix

    # Load feasibility score - rewards routes where demand can be accommodated
    available_capacity = current_load.unsqueeze(1) - delivery_node_demands  # Shape: (pomo_size, N+1)
    load_feasibility_score = torch.where(available_capacity >= 0, 0.0, float('-inf'))  # Shape: (pomo_size, N+1)

    # Open routes remain
    available_capacity_open = current_load_open.unsqueeze(1) - delivery_node_demands_open  # Shape: (pomo_size, N+1)
    load_feasibility_score_open = torch.where(available_capacity_open >= 0, 0.0, float('-inf'))  # Shape: (pomo_size, N+1)

    # Time window compatibility score
    time_score = torch.where((arrival_times < time_windows[:, 0].unsqueeze(0)) | 
                             (arrival_times > time_windows[:, 1].unsqueeze(0)), 
                             float('-inf'), 0.0)  # Shape: (pomo_size, N+1)

    # Route duration limits
    length_score = torch.where(current_length.unsqueeze(1) - current_distance_matrix >= 0, 0.0, float('-inf'))  # Shape: (pomo_size, N+1)

    # Combine all scores carefully eliminating invalid entries from previous calculations
    combined_scores = distance_score + load_feasibility_score + load_feasibility_score_open + time_score + length_score

    # Add controlled randomness to avoid local optima
    noise = torch.normal(0, 0.01, size=combined_scores.shape).cuda()  # Assuming the operation is on GPU

    # Final heuristic scores
    heuristic_scores = combined_scores + noise

    # Ensuring metrics are finite across all dimensions
    heuristic_scores = torch.clamp(heuristic_scores, min=-1e10, max=1e10)

    # Ensure to exclude any embarrassingly non-finite scores before returning
    heuristic_scores[torch.isinf(heuristic_scores)] = float('inf')
    heuristic_scores = torch.where(torch.isnan(heuristic_scores), float('inf'), heuristic_scores)

    return heuristic_scores
```
