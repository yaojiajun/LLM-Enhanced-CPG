```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    epsilon = 1e-8
    pomo_size, N_plus_1 = current_distance_matrix.shape

    # Distance score: shorter distances are better (inverting scores for maximization)
    distance_score = -current_distance_matrix

    # Capacity feasibility scores
    delivery_feasible = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    road_capacity_score = delivery_feasible

    # Time window adherence scores: profit based on time window matches
    earliest_times = time_windows[:, 0]
    latest_times = time_windows[:, 1]
    service_adherence = ((arrival_times <= latest_times.unsqueeze(0)).float() * 
                         (arrival_times >= earliest_times.unsqueeze(0)).float())
    
    # Duration limits
    duration_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix + pickup_node_demands.unsqueeze(0)).float()
    
    # Loss on infeasible options: penalties for unserviceable nodes
    infeasibility_penalty = 1.0 - (road_capacity_score * service_adherence * duration_feasibility)
    
    # Randomness component to encourage exploration
    randomness_adjustment = torch.rand_like(current_distance_matrix) * 0.1

    # Compute the heuristic score matrix
    heuristic_scores = (distance_score + randomness_adjustment) * road_capacity_score * service_adherence * duration_feasibility
    heuristic_scores -= infeasibility_penalty * (1.0 / (current_length.unsqueeze(1) + epsilon))  # Controlled decay on infeasibility

    # Ensure no NaN or infinities appear
    heuristic_scores = torch.clamp(heuristic_scores, min=-1e10, max=1e10)

    return heuristic_scores
```
