```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Define an epsilon for numerical stability
    epsilon = 1e-8

    # Get shapes for broadcasting
    pomo_size, num_nodes = current_distance_matrix.shape
    
    # Compute effective capacities
    effective_loads = current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0).clone()
    effective_loads_open = current_load_open.unsqueeze(1) - delivery_node_demands_open.unsqueeze(0).clone()

    # Ensure no negative values using torch.clamp
    capacity_mask = torch.clamp(effective_loads, min=0)
    capacity_open_mask = torch.clamp(effective_loads_open, min=0)

    # Using arrival times and time window limits
    earliest_arrivals = arrival_times + current_distance_matrix
    arrival_with_times = earliest_arrivals >= time_windows[:, 0].unsqueeze(0)
    arrival_with_windows = earliest_arrivals <= time_windows[:, 1].unsqueeze(0)
    time_window_mask = arrival_with_times & arrival_with_windows

    # Aggregate constraints
    in_capacity_mask = capacity_mask > 0
    open_route_capacity_mask = capacity_open_mask > 0
    
    # Apply all constraints
    feasibility_mask = in_capacity_mask & time_window_mask

    # Combine different penalizing factors into the heuristic score
    base_score = -current_distance_matrix.clone()
    
    # Encourage routes within time constraints
    temporary_scores_time_mat = base_score * time_window_mask
    base_scores_with_constraints = temporary_scores_time_mat * feasibility_mask

    # Add controlled randomness to avoid local optima
    randomness_score = torch.normal(mean=0.0, std=1.0, size=base_scores_with_constraints.shape).clamp(-0.5, 0.5)
    final_heuristic_scores = base_scores_with_constraints + randomness_score

    # Final masking
    final_heuristic_scores[~feasibility_mask] = float('-inf')  # Rule out infeasible movements

    # Return finalized scores while ensuring finiteness
    return final_heuristic_scores
```
