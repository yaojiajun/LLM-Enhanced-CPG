```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Small constant for numerical stability
    epsilon = 1e-8
    
    # Calculate available capacity for delivery
    available_capacity = current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)
    # Clamp values to prevent negative capacities
    available_capacity = torch.clamp(available_capacity, min=0)
    
    # Calculate available capacity for open routes
    available_capacity_open = current_load_open.unsqueeze(1) - delivery_node_demands_open.unsqueeze(0)
    available_capacity_open = torch.clamp(available_capacity_open, min=0)

    # Check time window feasibility
    earliest_start = time_windows[:, 0]
    latest_end = time_windows[:, 1]
    feasible_time = (arrival_times.unsqueeze(1) >= earliest_start.unsqueeze(0)) & (arrival_times.unsqueeze(1) <= latest_end.unsqueeze(0))
    
    # Calculate route duration feasibility
    route_length = current_length.unsqueeze(1) - current_distance_matrix
    route_length_remain = torch.clamp(route_length, min=0)
    
    # Score calculation
    load_score = available_capacity / (current_load.unsqueeze(1) + epsilon) * global_random_noise + available_capacity_open / (current_load_open.unsqueeze(1) + epsilon)
    time_w_score = feasible_time.sum(dim=1) / (time_windows.size(0) + epsilon)
    length_score = route_length_remain / (current_length.unsqueeze(1) + epsilon)

    # Combine scores: with weights, give dominance to capacity & duration constraints
    score_matrix = 0.4 * load_score + 0.3 * time_w_score + 0.3 * length_score
    
    # Control randomness with noise added
    global_random_noise = torch.empty(score_matrix.size()).uniform_(-0.1, 0.1).to(score_matrix.device)
    score_matrix += global_random_noise
    
    # Ensure all outputs are finite values
    return torch.clamp(score_matrix, min=-float('inf'), max=float('inf'))
```
