```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    epsilon = 1e-8
    pomo_size, N_plus_1 = current_distance_matrix.shape
    
    # Heuristic score based on distance
    distance_score = -current_distance_matrix
    
    # Capacity check
    delivery_capacity_score = (current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)) / (current_load.unsqueeze(1) + epsilon)
    delivery_capacity_score[delivery_capacity_score < 0] = -float('inf')  # infeasible
    
    # Time window constraint
    time_window_score = torch.where(
        (arrival_times.unsqueeze(1) >= time_windows[:, 0]) & (arrival_times.unsqueeze(1) <= time_windows[:, 1]),
        torch.tensor(1.0),
        torch.tensor(-float('inf'))
    )
    
    # Current length constraint for route duration
    length_score = (current_length.unsqueeze(1) - current_distance_matrix) / (current_length.unsqueeze(1) + epsilon)
    length_score[length_score < 0] = -float('inf')  # infeasible

    # Combined score
    combined_score = (
        distance_score + 
        delivery_capacity_score + 
        time_window_score + 
        length_score
    )
    
    # Adding some controlled randomness to the scoring to avoid local optima
    noise = torch.randn_like(combined_score) * 0.01
    combined_score += noise

    # Clamp scores to prevent infinities and remain finite
    combined_score[torch.isinf(combined_score)] = -1e10 
    combined_score[torch.isnan(combined_score)] = -1e10 

    return combined_score
```
