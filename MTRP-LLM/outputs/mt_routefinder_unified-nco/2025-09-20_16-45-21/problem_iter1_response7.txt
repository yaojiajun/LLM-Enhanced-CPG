```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:

    # Ensure mask for the valid nodes based on vehicle capacity
    capacity_mask = current_load.unsqueeze(1) >= delivery_node_demands[:-1].unsqueeze(0)  # Ignore depot
    capacity_open_mask = current_load_open.unsqueeze(1) >= delivery_node_demands_open[:-1].unsqueeze(0)

    # Create valid index mask based on the time windows
    current_time = arrival_times
    time_mask = (current_time.unsqueeze(1) >= time_windows[:-1, 0].unsqueeze(0)) & \
                (current_time.unsqueeze(1) <= time_windows[:-1, 1].unsqueeze(0))

    # JIT inference on duration remaining constraint
    duration_budget_mask = current_length.unsqueeze(1) >= (current_distance_matrix[:-1, :] + 1e-8)

    # Combine all masks for feasible edges
    feasibility_mask = capacity_mask & time_mask & duration_budget_mask & capacity_open_mask

    # Calculate the potential distance score using valid edges only
    scores = torch.where(feasibility_mask, 
                         1 / (current_distance_matrix + 1e-8),  # distance score -> smaller distance preferred
                         torch.tensor(float('-inf'), device=current_distance_matrix.device))  # invalid edges scoring

    # Introduce some controlled randomness to explore solutions better
    random_noise = (torch.rand(scores.size(), device=current_distance_matrix.device) - 0.5) * 0.1
    scores += random_noise

    # Clamp scores to avoid invalid values
    scores = torch.clamp(scores, min=float('-1e10'), max=float('1e10'))

    # Normalize for better spreading of scores while avoiding division by zero
    norm_scores = scores / (torch.max(scores, dim=1, keepdim=True)[0] + 1e-8)

    return norm_scores
```
