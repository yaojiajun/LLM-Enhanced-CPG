```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    epsilon = 1e-8

    # Extract time window for earliest and latest service times
    earliest_service_times = time_windows[:, 0:1]  # Shape: (N+1, 1)
    latest_service_times = time_windows[:, 1:2]    # Shape: (N+1, 1)

    # Calculate remaining time window feasibility
    remaining_time_windows = (latest_service_times - arrival_times) + epsilon
    feasible_time_windows_mask = (arrival_times >= earliest_service_times) & (remaining_time_windows > 0)
    
    # Compute load feasibility for deliveries
    delivery_feasibility = current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)  # Shape: (pomo_size, N+1)
    
    # Open route capacity checks for backhauls
    open_route_capacities = current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0) 
    
    # Avoid negative distances, applying a mask for feasible time windows and deliveries
    valid_mask = feasible_time_windows_mask & delivery_feasibility

    # Normalize distances with condition of being in range, adding stabilization factors
    normalized_distances = torch.where(valid_mask, current_distance_matrix / (current_load.unsqueeze(1) + epsilon), torch.zeros_like(current_distance_matrix))
    
    # Aggregate distance penalties for infeasibility reducing score
    infeasible_penalty = torch.where(~valid_mask, float('-inf') * torch.ones_like(current_distance_matrix), torch.zeros_like(current_distance_matrix))

    # Create a score matrix
    score_matrix = normalized_distances + infeasible_penalty

    # Adding controlled randomness element (jitters) to encourage exploration
    randomness_component = torch.rand_like(score_matrix) * 0.1  # Jitter, scaling factor for randomness
    score_matrix += randomness_component

    # Clamp and retain only finite values
    score_matrix = torch.where(torch.isfinite(score_matrix), score_matrix, torch.tensor(float('-inf')).to(score_matrix.device))

    return score_matrix
```
