```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Constants
    epsilon = 1e-8
    small_randomness = torch.rand(current_distance_matrix.shape) * 0.1  # Controlled randomness to avoid local optima    

    # Capacity based score
    capacity_score = current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)
    capacity_score[capacity_score < 0] = -torch.inf  # Penalty for inadequate capacity
    
    # Time window score
    timer_overlaps = ((arrival_times.unsqueeze(1) >= time_windows[:, 0].unsqueeze(0)) & 
                      (arrival_times.unsqueeze(1) <= time_windows[:, 1].unsqueeze(0)))
    time_window_score = torch.where(timer_overlaps, 1.0, -torch.inf) # Positive score within time windows.
    
    # Duration limit score
    duration_score = current_length.unsqueeze(1) - current_distance_matrix
    duration_score[duration_score < 0] = -torch.inf  # Infeasible duration if negative
    
    # Overall score combination
    overall_score = capacity_score + time_window_score + duration_score
    
    # Normalize and clamp scores to keep within bounds
    overall_score = torch.clamp(overall_score, min=-1000.0, max=1000.0)

    # Adding randomness to break ties and avoid local optima
    final_scores = overall_score + small_randomness    
    final_scores[~torch.isfinite(final_scores)] = -torch.inf  # Replace non-finite with negative infinity

    return final_scores
```
