```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Constants
    epsilon = 1e-8
    batch_size, num_nodes = current_distance_matrix.shape
    
    # Calculate base feasibilities
    delivery_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    delivery_feasibility_open = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()
    
    # Time window checks
    current_time = arrival_times.unsqueeze(1) + current_distance_matrix
    time_feasibility = ((current_time >= time_windows[:, 0].unsqueeze(0)) & (current_time <= time_windows[:, 1].unsqueeze(0))).float()
    
    # Duration checks
    remaining_time = (current_length.unsqueeze(1) - current_distance_matrix) > epsilon
    duration_feasibility = remaining_time.float()
    
    # Combine feasibilities
    feasible = delivery_feasibility * delivery_feasibility_open * time_feasibility * duration_feasibility
    
    # Compute heuristic scores (Scaled based on distance)
    heuristic_scores = (1 / (current_distance_matrix + epsilon)) * feasible
    
    # Introduce controlled randomness
    randomness = torch.rand(batch_size, num_nodes).to(current_distance_matrix.device) * 0.01
    heuristic_scores += randomness
    
    # Clamp to finite values
    heuristic_scores[~torch.isfinite(heuristic_scores)] = 0.0
    
    return heuristic_scores
```
