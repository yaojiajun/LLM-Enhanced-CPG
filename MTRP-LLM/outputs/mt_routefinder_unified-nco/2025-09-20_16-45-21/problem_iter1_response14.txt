```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    epsilon = 1e-8

    # Initialize score matrices
    n_vehicles, n_nodes = current_distance_matrix.shape
    heuristic_scores = torch.zeros((n_vehicles, n_nodes), device=current_distance_matrix.device)

    # Calculate the distance weight, minimizing distance
    distance_weight = 1.0 / (current_distance_matrix + epsilon)

    # Ensure that demands and loads do not exceed their limits
    valid_delivery = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    valid_open = (current_load_open.unsqueeze(1) >= delivery_node_demands_open.unsqueeze(0)).float()

    # Time window checks
    within_time_window = ((arrival_times <= time_windows[:, 1].unsqueeze(0)) & 
                          (arrival_times >= time_windows[:, 0].unsqueeze(0))).float()

    # Route length limit
    valid_length = (current_length.unsqueeze(1) >= current_distance_matrix).float()

    # Evaluate final scores based on these constraints
    scores_factors = (valid_delivery * valid_open * within_time_window * valid_length)

    # Multiply by distance weight to get the final heuristic
    heuristic_scores = scores_factors * distance_weight

    # Introduce randomness to escape local optima
    random_factor = torch.rand_like(heuristic_scores) * 0.1
    heuristic_scores += random_factor

    # Clamp scores to avoid any invalid values
    heuristic_scores = torch.clamp(heuristic_scores, min=0.0, max=torch.max(heuristic_scores))

    return heuristic_scores
```
