```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    epsilon = 1e-8

    # Compute delivery feasibility
    delivery_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).to(torch.float)  # (pomo_size, N+1)
    
    # Compute time window feasibility
    current_time_window_resource = (arrival_times < time_windows[:, 1].unsqueeze(0)).to(torch.float) & (arrival_times >= time_windows[:, 0].unsqueeze(0)).to(torch.float)  # (pomo_size, N+1)
    
    # Compute remaining length requirements
    length_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix + epsilon).to(torch.float)  # (pomo_size, N+1)
    
    # Score assignments based on feasibility checks - using respective weights
    delivery_weight = 0.4
    time_window_weight = 0.3
    length_weight = 0.3

    feas_score = (delivery_weight * delivery_feasibility) + (time_window_weight * current_time_window_resource) + (length_weight * length_feasibility)  # (pomo_size, N+1)

    # Compute heuristic scores inversely with the weighted distance matrix adjusted by feasibility
    heuristic_scores = torch.where(feas_score > 0, 1 / (current_distance_matrix + epsilon), -torch.inf)  # Guard against div by zero with added epsilon

    # Add controlled randomness to avoid local optima convergence
    randomness = torch.rand_like(heuristic_scores) * 1e-2  # Small random fluctuations
    heuristic_scores += randomness

    # Clamping heuristics between a fixed range to maintain numerical stability
    heuristic_scores = torch.clamp(heuristic_scores, min=-1E10, max=1E10)

    return heuristic_scores
```
