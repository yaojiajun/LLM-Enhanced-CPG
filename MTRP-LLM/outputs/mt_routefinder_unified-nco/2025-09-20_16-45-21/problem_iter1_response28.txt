```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    epsilon = 1e-8

    # Delivery feasibility based on current load and demands
    delivery_feasibility = (current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)).clamp(min=0)
    delivery_score = delivery_feasibility / (current_distance_matrix + epsilon)

    # Open route feasibility
    open_delivery_feasibility = (current_load_open.unsqueeze(1) - delivery_node_demands_open.unsqueeze(0)).clamp(min=0)
    open_route_score = open_delivery_feasibility / (current_distance_matrix + epsilon)

    # Time window constraints
    current_time = arrival_times.view(-1, 1) + current_distance_matrix
    time_window_ps = (current_time >= time_windows[:, 0].unsqueeze(0)) & (current_time <= time_windows[:, 1].unsqueeze(0))

    time_window_score = time_window_ps.float()

    # Duration limits check
    duration_score = (current_length.unsqueeze(1) - current_distance_matrix).clamp(min=0) / (current_length.unsqueeze(1) + epsilon)

    # Pickup demand feasibility
    pickup_feasibility = (current_load.unsqueeze(1) - pickup_node_demands.unsqueeze(0)).clamp(min=0)

    # Combine scores with random component for better exploration
    random_noise = torch.rand_like(current_distance_matrix) * 0.1
    score_matrix = (delivery_score + open_route_score + time_window_score + duration_score + pickup_feasibility.float() + random_noise) / 5

    # Normalize and assign finite score matrix
    score_matrix = score_matrix.clamp(min=0, max=1)
    return score_matrix
```
