```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Normalize distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_distance if max_distance > 0 else current_distance_matrix
    
    # Enhanced randomness
    rand_weights = torch.rand_like(normalized_distance) * 0.5 + 0.5  # Random weights in [0.5, 1.0]

    # Heuristic calculations
    score1 = torch.sigmoid(1 - normalized_distance) * rand_weights  # Favor closer nodes
    score2 = torch.relu(normalized_distance) * (1 - rand_weights)  # Penalize further distances
    
    # Additional randomness combined with capacity considerations
    capacity_penalty = (delivery_node_demands_open - current_load_open.unsqueeze(1)).clamp(min=0)  # Ensure vehicle can meet delivery demands
    time_window_penalty = (arrival_times - time_windows[:, 0].unsqueeze(0)).clamp(min=0)  # Ensure arrivals within time windows
    
    # Combine all scores with capacity and time window penalties
    heuristic_scores = score1 - score2 - capacity_penalty - time_window_penalty
    
    # Normalize scores
    heuristic_scores = torch.clamp(heuristic_scores, min=-1, max=1)

    return heuristic_scores
```
