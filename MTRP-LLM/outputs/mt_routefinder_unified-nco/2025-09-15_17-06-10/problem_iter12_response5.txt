```python
def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Introduce varied activation functions for scoring
    rand_weights = torch.rand_like(current_distance_matrix) * 0.5 + 0.5  # Random weights between 0.5 and 1.0
    
    normalized_distance = current_distance_matrix / (torch.max(current_distance_matrix, dim=1, keepdim=True)[0] + 1e-6)
    distance_penalty = torch.exp(torch.neg(normalized_distance))  # Exponential penalty for longer distances
    
    # Compute score terms with different activation functions
    score1 = torch.sin(normalized_distance) * rand_weights  # Using sine for varied edge evaluations
    score2 = torch.max(torch.zeros_like(current_distance_matrix), current_length.unsqueeze(1) - current_distance_matrix)  # Ensure non-negativity on available length
    
    # Adaptive weighting for exploration and exploitation
    adaptability_factor = torch.sigmoid(current_load.unsqueeze(1) / 2)  # Weighting based on current load
    adaptive_score = (score1 - distance_penalty) * adaptability_factor
    
    heuristic_scores = adaptive_score + score2

    # Add randomness in the scores for enhanced exploration
    heuristic_scores += torch.randn_like(heuristic_scores) * 0.1

    return heuristic_scores
```
