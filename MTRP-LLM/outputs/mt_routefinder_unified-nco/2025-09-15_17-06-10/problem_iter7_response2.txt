```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    batch_size, num_nodes = current_distance_matrix.shape
    rand_weights = torch.rand(batch_size, num_nodes, device=current_distance_matrix.device) * 0.1 + 0.9  # Random weights between 0.9 and 1.0
    
    # Normalizing distance matrix and calculating scores
    normalized_distance = current_distance_matrix / (torch.max(current_distance_matrix, dim=1, keepdim=True)[0] + 1e-10)
    
    # Heuristic indicators
    load_penalty = (delivery_node_demands.unsqueeze(0) > current_load.unsqueeze(1)).float() * -1e5  # Large penalty for infeasible delivery due to load
    time_window_violation = ((arrival_times.unsqueeze(1) < time_windows[:, :, 0]) | 
                             (arrival_times.unsqueeze(1) > time_windows[:, :, 1])).float() * -1e5  # Large penalty for time window violations
                             
    # Calculate scores
    score1 = torch.tanh(normalized_distance) * rand_weights
    score2 = (torch.relu(current_distance_matrix) + load_penalty + time_window_violation) * (1 - rand_weights)
    
    # Combine scores and introduce randomness
    heuristic_scores = score1 - score2 + (torch.rand_like(score1) * 0.1)  # Adding randomness to encourage exploration

    return heuristic_scores
```
