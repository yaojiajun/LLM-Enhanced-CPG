```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Normalize the distance matrix to prevent division by zero
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / (max_distance + 1e-6)
    
    # Evaluate feasibility for delivery and pickup based on load and demands
    delivery_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)).float()
    pickup_feasibility = (current_load_open.unsqueeze(1) >= pickup_node_demands.unsqueeze(0)).float()

    # Check time window feasibility 
    current_time = arrival_times.unsqueeze(1) + normalized_distance  # Estimate next arrival times
    time_window_feasibility = ((current_time >= time_windows[:, 0].unsqueeze(0)) & 
                                (current_time <= time_windows[:, 1].unsqueeze(0))).float()

    # Combine the feasibility matrices
    feasibility_matrix = delivery_feasibility * pickup_feasibility * time_window_feasibility
    
    # Heuristic score based on the normalized distance and feasibility
    heuristic_scores = feasibility_matrix * (1 - normalized_distance)  # Favor lower distances

    # Introduce diversity to avoid local optima
    diversity_factor = torch.rand_like(heuristic_scores) * 0.1
    heuristic_scores += diversity_factor

    return heuristic_scores
```
