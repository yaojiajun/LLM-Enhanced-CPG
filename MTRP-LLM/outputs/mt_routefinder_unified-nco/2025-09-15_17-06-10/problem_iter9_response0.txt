```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Random weights for enhancing exploration
    rand_weights1 = torch.rand_like(current_distance_matrix) * 0.5 + 0.5  # More stable random range
    rand_weights2 = torch.rand_like(current_distance_matrix) * 0.5 + 0.5  # More stable random range

    # Normalizing distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / (max_distance + 1e-5)

    # Computing score components
    score1 = torch.tanh(normalized_distance) * rand_weights1
    
    # Varying the penalty based on remaining load and delivery demands
    load_penalty = (current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)).clamp(min=0) # Positive values if feasible
    demand_influence = delivery_node_demands.unsqueeze(0) / (current_load.unsqueeze(1) + 1e-5)  # Avoid division by zero

    # Weighting penalties based on time window feasibility
    time_window_scores = (arrival_times < time_windows[:, 0].unsqueeze(0)).float() * -1.0 + (arrival_times > time_windows[:, 1].unsqueeze(0)).float() * -1.0

    # Ensemble of heuristics
    score2 = (torch.relu(torch.exp(current_distance_matrix)) + rand_weights2 + load_penalty - demand_influence + time_window_scores)

    # Combined heuristic scores
    heuristic_scores = score1 - score2

    # Adding randomness to disrupt local optima convergence
    randomness = torch.rand_like(heuristic_scores) * 0.1  # Small perturbation
    heuristic_scores += randomness

    return heuristic_scores
```
