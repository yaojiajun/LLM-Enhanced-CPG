```python
def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Initialize random weights for variability
    rand_weights1 = torch.rand_like(current_distance_matrix) * 0.5 + 0.5  # Scale weights to [0.5, 1.0]
    rand_weights2 = torch.rand_like(current_distance_matrix) * 0.5 + 0.5

    # Normalize distances and compute heuristic indicators
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_distance
    capacity_exceeded = (delivery_node_demands.unsqueeze(0) > current_load.unsqueeze(1)).float() * -1e6
    time_window_violation = ((arrival_times.unsqueeze(1) < time_windows[:, 0]) | (arrival_times.unsqueeze(1) > time_windows[:, 1])).float() * -1e6
    length_exceeded = (torch.cumsum(current_distance_matrix, dim=1) > current_length.unsqueeze(1)).float() * -1e6
    
    # Calculate scores
    score1 = torch.tanh(normalized_distance) * rand_weights1
    score2 = torch.relu(torch.exp(current_distance_matrix)) * rand_weights2
    
    # Aggregate scores from various factors
    heuristic_scores = score1 - score2 + capacity_exceeded + time_window_violation + length_exceeded
    
    # Incorporate a dynamic weighting based on proximity
    proximity_weights = 1.0 / (current_distance_matrix + 1e-6)
    heuristic_scores += proximity_weights * 0.1  # Small influence from proximity

    return heuristic_scores
```
