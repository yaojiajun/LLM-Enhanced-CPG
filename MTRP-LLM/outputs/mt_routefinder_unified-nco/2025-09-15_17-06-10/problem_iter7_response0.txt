```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Random weights with scaling to introduce variability
    rand_weights = torch.rand_like(current_distance_matrix) * 0.5 + 0.5  # Scale between 0.5 and 1.0
    scaled_distance = current_distance_matrix / (torch.max(current_distance_matrix, dim=1, keepdim=True)[0] + 1e-6)

    # Heuristic Indicators
    load_capacity_violation = (delivery_node_demands.unsqueeze(0) > current_load.unsqueeze(1)).float()  # (pomo_size, N+1)
    time_window_violation = ((arrival_times.unsqueeze(1) < time_windows[:, 0]) | (arrival_times.unsqueeze(1) > time_windows[:, 1])).float()
    
    # Generating scores using different activation functions and weighting
    score1 = torch.sigmoid(scaled_distance) * rand_weights
    score2 = torch.relu(torch.pow(scaled_distance, 2)) + rand_weights * load_capacity_violation + time_window_violation

    # Compute combined heuristic scores
    heuristic_scores = score1 - score2

    # Introduce randomness to avoid local optima (shuffling based randomness)
    random_multiplier = torch.rand_like(heuristic_scores) * 0.1 + 0.95  # Small random multiplicative factor
    heuristic_scores *= random_multiplier

    # Normalize scores to [0, 1] range
    heuristic_scores = (heuristic_scores - heuristic_scores.min(dim=1, keepdim=True)[0]) / \
                       (heuristic_scores.max(dim=1, keepdim=True)[0] - heuristic_scores.min(dim=1, keepdim=True)[0] + 1e-6)

    return heuristic_scores
```
