```python
import torch
import torch.nn.functional as F

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Calculate feasibility scores based on capacity and load constraints
    capacity_feasibility = ((current_load.unsqueeze(1) >= delivery_node_demands[1:]).float() + 
                             (current_load_open.unsqueeze(1) >= delivery_node_demands_open[1:]).float()) / 2

    # Time window violation score
    time_window_violation = F.relu(arrival_times - time_windows[:, 1].unsqueeze(0)) + F.relu(time_windows[:, 0].unsqueeze(0) - arrival_times)
    time_window_score = 1 - (time_window_violation / time_windows[:, 1].max())  # Normalize
    
    # Route length feasibility score
    length_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix).float()
    
    # Combine scores using weighted sum with activation functions for non-linearity
    heuristic_scores = (0.4 * F.sigmoid(current_distance_matrix) +
                        0.4 * capacity_feasibility +
                        0.1 * length_feasibility +
                        0.1 * time_window_score)

    # Introduce randomness to enhance exploration
    randomness = torch.rand_like(heuristic_scores) * 0.1  # Small random noise
    heuristic_scores += randomness
    
    # Normalize scores to standardize the range
    heuristic_scores = (heuristic_scores - heuristic_scores.min()) / (heuristic_scores.max() - heuristic_scores.min())

    return heuristic_scores
```
