```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Normalize the distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_distance if max_distance > 0 else current_distance_matrix
    
    # Introduce randomness with varying weights for exploration
    exploration_factor = torch.rand_like(normalized_distance) * 0.2 + 0.5  # Random weights for diversified scoring
    
    # Calculate score based on distance and constraints
    feasible_mask = (current_load.unsqueeze(1) >= delivery_node_demands.unsqueeze(0)) & \
                    (current_length.unsqueeze(1) >= normalized_distance) & \
                    (arrival_times <= time_windows[:, 1].unsqueeze(0)) & \
                    (arrival_times >= time_windows[:, 0].unsqueeze(0))
    
    # Feasible score
    feasible_score = torch.where(feasible_mask, -normalized_distance, float('inf')) # Lower distances yield better scores
    
    # Randomness score to promote exploration
    randomness_score = (exploration_factor * 2 - 1) * torch.sigmoid(-feasible_score)  # Muted by feasible scores
    
    # Combine scores, with a focus on both distance minimization and exploration
    heuristic_scores = feasible_score + randomness_score
    
    # Normalize scores to ensure they fit in the (-1, 1) range
    heuristic_scores = (heuristic_scores - heuristic_scores.min()) / (heuristic_scores.max() - heuristic_scores.min() + 1e-10)  # Avoid division by zero
    heuristic_scores = heuristic_scores * 2 - 1  # Scale to [-1, 1]
    
    return heuristic_scores
```
