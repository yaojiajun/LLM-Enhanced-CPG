```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Random weights for enhancing exploration
    rand_weights = torch.rand_like(current_distance_matrix) * 0.5 + 0.5  # Scale to [0.5, 1.0]
    
    # Normalize current distance matrix
    max_distance = torch.max(current_distance_matrix, dim=1, keepdim=True).values
    normalized_distance = current_distance_matrix / (max_distance + 1e-6)  # Prevent division by zero
    
    # Applying an exponential transformation to emphasize larger distances while retaining positive scores
    exp_distance = torch.exp(-normalized_distance)
    
    # Compute scores for delivery and pickup feasibility
    delivery_feasibility = (current_load.unsqueeze(1) - delivery_node_demands[None, :]) >= 0
    pickup_feasibility = (current_load_open.unsqueeze(1) + pickup_node_demands[None, :]) <= current_load.unsqueeze(1)

    # Arrival time assessment against time windows
    within_time_windows = (arrival_times <= time_windows[:, 1].unsqueeze(0)) & (arrival_times >= time_windows[:, 0].unsqueeze(0))
    
    # Combine scores using adaptive weighting and introduce non-linear functions
    delivery_score = exp_distance * delivery_feasibility.float()
    pickup_score = exp_distance * pickup_feasibility.float() * 0.7  # Weighted slightly lower
    time_window_score = normalized_distance * within_time_windows.float() * 1.5  # Give higher importance to time feasibility
    
    # Final heuristic scores combining the elements
    heuristic_scores = (0.4 * delivery_score + 0.3 * pickup_score + 0.3 * time_window_score) * rand_weights
    
    # Normalize scores to maintain uniformity
    heuristic_scores = (heuristic_scores - torch.min(heuristic_scores)) / (torch.max(heuristic_scores) - torch.min(heuristic_scores) + 1e-6)

    return heuristic_scores
```
