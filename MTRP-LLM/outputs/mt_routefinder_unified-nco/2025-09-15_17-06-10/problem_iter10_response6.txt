```python
def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Normalize distance matrix with adaptive scaling
    max_distance = torch.max(current_distance_matrix)
    min_distance = torch.min(current_distance_matrix)
    scaled_distance = (current_distance_matrix - min_distance) / (max_distance - min_distance) if max_distance > min_distance else current_distance_matrix

    # Introduce dynamic randomness within a specified range
    rand_weights = torch.randn_like(scaled_distance) * 0.3 + 0.7  # Mean centered around 0.7 for bias towards shorter routes

    # Compute heuristic scores with enhanced normalization
    score1 = torch.sigmoid(torch.tanh(scaled_distance)) * rand_weights  # Favor shorter distances
    score2 = torch.relu(torch.cos(scaled_distance * torch.pi)) * (1 - rand_weights)  # Penalize based on distance
    score3 = torch.tanh(torch.sin(scaled_distance * 2 * torch.pi))  # Enhance randomness and exploration

    # Combine heuristic scores with adaptive adjustments
    heuristic_scores = score1 - score2 + score3

    # Normalize and clamp heuristic scores for stability
    heuristic_scores = (heuristic_scores - torch.min(heuristic_scores)) / (torch.max(heuristic_scores) - torch.min(heuristic_scores))  # Scale to [0, 1]
    heuristic_scores = heuristic_scores * 2 - 1  # Rescale to [-1, 1]

    return heuristic_scores
```
