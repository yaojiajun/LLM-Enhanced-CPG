```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Random factors for enhanced diversity
    rand_factors = torch.rand_like(current_distance_matrix) * 0.5 + 0.5  # Range [0.5, 1.0]

    # Normalization of the distance matrix to the range [0, 1]
    max_dist = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_dist if max_dist > 0 else current_distance_matrix

    # Normalized metrics for delivery demand and load capacity
    capacity_utilization = (current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)) / current_load.unsqueeze(1)
    capacity_utilization[capacity_utilization < 0] = 0  # Ensure non-negative values

    # Considering time windows for feasibility
    time_window_penalty = torch.zeros_like(time_windows[:, 0])
    arrival_time_diff = arrival_times - time_windows[:, 0]
    for i in range(arrival_time_diff.shape[1]):
        time_window_penalty += torch.where(arrival_time_diff < 0, 1, 0)

    # Compute heuristic scores based on distance, capacity, and time constraints
    score_distance = (1 - normalized_distance) * rand_factors
    score_capacity = capacity_utilization * 0.7  # 70% weight on capacity
    score_time = (1 - time_window_penalty.unsqueeze(1) * 0.3)  # 30% weight on time windows

    # Final heuristic scores combining all metrics
    heuristic_scores = score_distance + score_capacity + score_time

    return heuristic_scores
```
