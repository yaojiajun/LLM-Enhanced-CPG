```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Normalize distance matrix with robust max to avoid division by zero
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / (max_distance + 1e-6)  # Add small epsilon for stability

    # Generate diverse random weights using a uniform distribution
    rand_weights1 = torch.rand_like(normalized_distance) * 0.5 + 0.5  # Weight from [0.5, 1.0]
    rand_weights2 = torch.rand_like(normalized_distance) * 0.5  # Weight from [0.0, 0.5]

    # Enhanced randomness with a mixture of distributions
    random_noise = torch.normal(mean=0.0, std=0.1, size=normalized_distance.shape).clamp(-0.1, 0.1)

    # Compute heuristic scores with nonlinear transformations
    score1 = torch.sigmoid(torch.tanh(normalized_distance) + random_noise) * rand_weights1  # Favor shorter distances with noise
    score2 = torch.relu(torch.exp(normalized_distance) + torch.cos(normalized_distance * 2 * torch.pi)) * (1 - rand_weights2)  # Penalize distances
    score3 = torch.tanh(torch.sin(normalized_distance * 2 * torch.pi)) * rand_weights2  # Enhance exploration

    # Combined heuristic scores:
    heuristic_scores = score1 - score2 + score3

    # Normalize scores to ensure they stay within reasonable bounds
    heuristic_scores = torch.clamp(heuristic_scores, min=-1, max=1)

    return heuristic_scores
```
