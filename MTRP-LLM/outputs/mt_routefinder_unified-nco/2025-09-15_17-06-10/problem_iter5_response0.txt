```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Generate random weights to introduce randomness
    rand_weights = torch.rand_like(current_distance_matrix)

    # Normalize distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_distance if max_distance > 0 else 1.0

    # Calculate scores based on various factors
    delivery_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands).float()
    pickup_feasibility = (current_load_open.unsqueeze(1) >= pickup_node_demands).float()
    
    time_window_violation = (
        (arrival_times < time_windows[:, 0].unsqueeze(0)) | 
        (arrival_times > time_windows[:, 1].unsqueeze(0))
    ).float()

    score1 = torch.tanh(normalized_distance) * rand_weights * delivery_feasibility * (1 - time_window_violation)
    score2 = torch.relu(torch.sin(current_distance_matrix)) * pickup_feasibility * (1 - time_window_violation) + rand_weights
    
    # Incorporating adaptive weights
    adaptive_weights = (delivery_node_demands + pickup_node_demands) / (1e-5 + current_load.unsqueeze(1) + current_load_open.unsqueeze(1))
    heuristic_scores = (score1 - score2) * adaptive_weights
    
    # Apply non-linear transformation and ensure normalization
    heuristic_scores = (heuristic_scores - torch.min(heuristic_scores)) / (torch.max(heuristic_scores) - torch.min(heuristic_scores) + 1e-5)

    return heuristic_scores
```
