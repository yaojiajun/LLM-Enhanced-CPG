```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Random weights for enhanced randomness
    rand_weights = torch.rand_like(current_distance_matrix)

    # Normalize distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_distance

    # Calculate arrival time penalties based on time windows
    earliest_arrival = time_windows[:, 0].unsqueeze(0)  # Shape (1, N+1)
    latest_arrival = time_windows[:, 1].unsqueeze(0)  # Shape (1, N+1)

    penalties = torch.zeros_like(normalized_distance)
    for i in range(normalized_distance.size(0)):
        late_penalty = (arrivals_times[i] > latest_arrival).float() * 10  # Arbitrary penalty for lateness
        early_penalty = (arrivals_times[i] < earliest_arrival).float() * (earliest_arrival - arrivals_times[i])  
        penalties[i] = late_penalty + early_penalty

    # Compute heuristic scores with hybrid transformations
    score1 = torch.tanh(normalized_distance) * rand_weights 
    score2 = torch.relu(torch.exp(current_distance_matrix)) + penalties + rand_weights

    # Incorporate capacity considerations
    available_capacity = current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0)  # Shape (pomo_size, N+1)
    capacity_scores = (available_capacity >= 0).float()

    # Incorporate time window adjustments
    time_window_scores = ((arrival_times <= latest_arrival) & (arrival_times >= earliest_arrival)).float()

    # Combine scores into final heuristic scores
    heuristic_scores = score1 - score2 + 0.5 * capacity_scores + 0.5 * time_window_scores

    return heuristic_scores
```
