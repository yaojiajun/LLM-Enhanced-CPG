```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Normalize distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_distance if max_distance > 0 else current_distance_matrix

    # Dynamic random weights with a more uniform range
    rand_weights = torch.rand_like(normalized_distance) * 0.5 + 0.5  # [0.5, 1.0]

    # Compute heuristic scores with nonlinear transformations
    score1 = torch.sigmoid(torch.tanh(normalized_distance)) * rand_weights  # Favor shorter distances
    score2 = torch.relu(torch.cos(current_distance_matrix)) * (1 - rand_weights)  # Penalize based on distance
    score3 = torch.tanh(torch.sin(normalized_distance * 2 * torch.pi))  # Enhance randomness

    # Combine heuristic scores
    heuristic_scores = score1 - score2 + score3

    # Ensure scores are normalized and bounded
    heuristic_scores = torch.clamp(heuristic_scores, min=-1, max=1)

    return heuristic_scores
```
