```python
def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:

    # Normalize distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_distance if max_distance > 0 else current_distance_matrix

    # Generate dynamic random weights within a uniform range
    rand_weights = torch.rand_like(normalized_distance) * 0.6 + 0.4  # [0.4, 1.0]

    # Compute heuristic scores using various non-linear transformations
    score1 = torch.sigmoid(1 - normalized_distance) * rand_weights  # Favor shorter distances
    score2 = torch.log1p(normalized_distance) * (1 - rand_weights)  # Penalize longer distances
    score3 = torch.tanh(normalized_distance * 2) * (rand_weights * 0.5)  # Add randomness component

    # Incorporate capacities and demands constraints to influence scoring
    capacity_constraint = (current_load.unsqueeze(1) >= delivery_node_demands) * (current_length.unsqueeze(1) >= current_distance_matrix)
    demand_constraint_open = (current_load_open.unsqueeze(1) >= delivery_node_demands_open) * (current_length.unsqueeze(1) >= current_distance_matrix)

    # Combine heuristic scores while considering the constraints
    heuristic_scores = (score1 * capacity_constraint.float() + score2 * (1 - capacity_constraint.float()))
    heuristic_scores += (score3 * demand_constraint_open.float())

    # Normalize the final heuristic scores
    heuristic_scores = torch.clamp(heuristic_scores, min=-1, max=1)

    return heuristic_scores
```
