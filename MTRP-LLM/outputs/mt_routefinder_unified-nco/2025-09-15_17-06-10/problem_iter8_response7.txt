```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, 
                  delivery_node_demands: torch.Tensor, 
                  current_load: torch.Tensor, 
                  delivery_node_demands_open: torch.Tensor, 
                  current_load_open: torch.Tensor, 
                  time_windows: torch.Tensor, 
                  arrival_times: torch.Tensor, 
                  pickup_node_demands: torch.Tensor, 
                  current_length: torch.Tensor) -> torch.Tensor:
    
    # Normalize the distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_distance if max_distance > 0 else current_distance_matrix
    
    # Generate random weights with a varying distribution for added randomness
    rand_weights = torch.randn_like(normalized_distance)
    
    # Calculate heuristic scores based on multiple features
    score1 = torch.sigmoid(normalized_distance) * rand_weights  # Distance factor with randomness
    score2 = torch.tanh(current_load.unsqueeze(1) - delivery_node_demands.unsqueeze(0))  # Capacity feasibility
    score3 = torch.relu(time_windows[:, 0] - arrival_times)  # Time window adherence (earliest arrival time)
    score4 = torch.relu(current_length.unsqueeze(1) - current_distance_matrix)  # Length constraint
            
    # Combine scores using adaptive significance
    heuristic_scores = score1 - score2 + score3 - score4
    
    # Introducing an ensemble effect by adding variability
    ensemble_variability = 0.1 * torch.randn_like(heuristic_scores)
    heuristic_scores += ensemble_variability
    
    return heuristic_scores
```
