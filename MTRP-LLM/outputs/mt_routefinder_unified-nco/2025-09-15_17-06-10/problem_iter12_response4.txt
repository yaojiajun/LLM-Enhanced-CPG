```python
def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Generate random weights for randomness in scoring
    rand_weights = torch.rand_like(current_distance_matrix)

    # Normalize distance matrix
    max_dist = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / (max_dist + 1e-6)

    # Calculate feasibility metrics
    capacity_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands)
    time_window_feasibility = (arrival_times <= time_windows[:, 1].unsqueeze(0)) & (arrival_times >= time_windows[:, 0].unsqueeze(0))
    duration_feasibility = (current_length.unsqueeze(1) >= current_distance_matrix)

    # Calculate combined score based on feasibility and distance
    feasibility_score = capacity_feasibility & time_window_feasibility & duration_feasibility
    distance_score = -normalized_distance * feasibility_score.float()

    # Combine scores with random weights for exploration
    heuristic_scores = distance_score + rand_weights

    return heuristic_scores
```
