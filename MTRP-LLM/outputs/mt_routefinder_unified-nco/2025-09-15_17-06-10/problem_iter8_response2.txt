```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Randomness factor to enhance exploration
    rand_weights = torch.rand_like(current_distance_matrix) * 0.1

    # Normalize distances to [0, 1]
    normalized_distance = current_distance_matrix / (torch.max(current_distance_matrix) + 1e-6)
    
    # Calculate scores based on different criteria
    delivery_capacity = (current_load.unsqueeze(1) >= delivery_node_demands).float()
    pickup_capacity = (current_load_open.unsqueeze(1) >= pickup_node_demands).float()
    
    # Time window feasibility
    time_feasibility = ((arrival_times + normalized_distance <= time_windows[:, 1].unsqueeze(0)) & 
                        (arrival_times + normalized_distance >= time_windows[:, 0].unsqueeze(0))).float()

    # Adaptive scoring mechanism
    score1 = (torch.sigmoid(1 - normalized_distance) * delivery_capacity * time_feasibility) + rand_weights
    score2 = (torch.tanh(normalized_distance) * pickup_capacity * time_feasibility) - rand_weights
    
    # Heuristic score calculation
    heuristic_scores = score1 - score2 + rand_weights

    return heuristic_scores
```
