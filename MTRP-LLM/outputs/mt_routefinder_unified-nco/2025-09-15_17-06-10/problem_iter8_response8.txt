```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Generate adaptive randomness for edge scoring
    rand_weights1 = torch.rand_like(current_distance_matrix) * 0.5 + 0.5  # Adjusted to be in [0.5, 1.0]
    rand_weights2 = torch.rand_like(current_distance_matrix) * 0.5 + 0.5
    rand_weights3 = torch.rand_like(current_distance_matrix) * 0.5 + 0.5
    rand_weights4 = torch.rand_like(current_distance_matrix)  # Full range

    # Normalize the distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / (max_distance + 1e-6)  # Add small value to avoid division by zero

    # Heuristic scoring using diverse transformations
    score1 = torch.sigmoid(normalized_distance) * rand_weights1
    score2 = torch.tanh(normalized_distance) * rand_weights2
    score3 = torch.cos(normalized_distance) * rand_weights3
    score4 = torch.sin(normalized_distance) * rand_weights4

    # Combine scores with additional transformation for exploration
    heuristic_scores = score1 - score2 + score3 - score4

    # Adjust scores based on load constraints
    load_factor = (current_load.unsqueeze(-1) >= delivery_node_demands.unsqueeze(0)).float()  # Allow visiting only feasible customers
    length_factor = (current_length.unsqueeze(-1) >= current_distance_matrix.sum(dim=1).unsqueeze(1)).float()  # Ensure route length limits

    heuristic_scores = heuristic_scores * load_factor * length_factor

    return heuristic_scores
```
