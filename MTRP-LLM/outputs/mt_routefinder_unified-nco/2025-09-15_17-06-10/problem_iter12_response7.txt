```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    
    # Random weights for enhancing edge selection randomness
    rand_weights1 = torch.rand_like(current_distance_matrix)
    rand_weights2 = torch.rand_like(current_distance_matrix)

    # Calculate metrics for customer demand balance and time window feasibility
    demand_balance = delivery_node_demands - pickup_node_demands
    time_window_feasibility = (arrival_times >= time_windows[:, 0].unsqueeze(0)) & (arrival_times <= time_windows[:, 1].unsqueeze(0))
    
    # Normalize distances and demand balance
    normalized_distance = current_distance_matrix / (torch.max(current_distance_matrix) + 1e-5)
    normalized_demand_balance = demand_balance / (torch.max(demand_balance) + 1e-5)
    
    # Use the capacity constraints and route length constraints to adjust scores
    load_feasibility = current_load.view(-1, 1) >= delivery_node_demands.unsqueeze(0)
    length_feasibility = current_length.view(-1, 1) >= current_distance_matrix
    
    # Compute heuristic scores based on various factors
    score1 = torch.tanh(normalized_distance) * torch.sigmoid(normalized_demand_balance) * load_feasibility * time_window_feasibility * rand_weights1
    score2 = torch.relu(torch.exp(current_distance_matrix)) + torch.relu(load_feasibility.float()) + rand_weights2
    
    # Aggregate the scores for final heuristic evaluation
    heuristic_scores = score1 - score2
    
    return heuristic_scores
```
