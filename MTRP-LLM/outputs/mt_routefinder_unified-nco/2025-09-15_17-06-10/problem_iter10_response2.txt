```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Normalize the distance matrix to [0, 1]
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / max_distance

    # Calculate feasibility masks based on load and time constraints
    load_feasibility = (current_load.unsqueeze(1) >= delivery_node_demands).float() * (current_load_open.unsqueeze(1) >= delivery_node_demands_open).float()
    time_feasibility = ((arrival_times <= time_windows[:, 1].unsqueeze(0)) & (arrival_times >= time_windows[:, 0].unsqueeze(0))).float()
    route_length_feasibility = (current_length.unsqueeze(1) >= normalized_distance).float()

    # Incorporate feasibility in the scoring
    feasibility_score = load_feasibility * time_feasibility * route_length_feasibility

    # Apply smooth activation functions to the normalized distance
    score1 = torch.sigmoid(1 - normalized_distance) * feasibility_score
    score2 = (1 - torch.sigmoid(normalized_distance)) * (1 - feasibility_score)

    # Combine scores with differentiation
    heuristic_scores = score1 - score2

    return heuristic_scores
```
