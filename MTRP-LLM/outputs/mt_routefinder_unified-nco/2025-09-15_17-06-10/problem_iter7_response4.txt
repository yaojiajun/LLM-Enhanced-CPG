```python
import torch

def heuristics_v2(current_distance_matrix: torch.Tensor, delivery_node_demands: torch.Tensor, current_load: torch.Tensor, delivery_node_demands_open: torch.Tensor, current_load_open: torch.Tensor, time_windows: torch.Tensor, arrival_times: torch.Tensor, pickup_node_demands: torch.Tensor, current_length: torch.Tensor) -> torch.Tensor:
    # Randomized weights
    rand_weights = torch.rand_like(current_distance_matrix)
    
    # Normalize the distance matrix
    max_distance = torch.max(current_distance_matrix)
    normalized_distance = current_distance_matrix / (max_distance + 1e-6)
    
    # Compute time window feasibility scores
    time_window_violation = (arrival_times < time_windows[:, 0].unsqueeze(0)) | (arrival_times > time_windows[:, 1].unsqueeze(0))
    time_window_scores = torch.where(time_window_violation, torch.tensor(-float('inf'), device=current_distance_matrix.device), torch.tensor(1.0, device=current_distance_matrix.device))
    
    # Active demand and load checks
    delivery_possible = (delivery_node_demands <= current_load.unsqueeze(1)) & (delivery_node_demands_open <= current_load_open.unsqueeze(1))
    load_scores = torch.where(delivery_possible, torch.tensor(1.0, device=current_distance_matrix.device), torch.tensor(0.0, device=current_distance_matrix.device))
    
    # Check current length feasibility
    length_possible = current_length.unsqueeze(1) - normalized_distance >= 0
    length_scores = torch.where(length_possible, torch.tensor(1.0, device=current_distance_matrix.device), torch.tensor(0.0, device=current_distance_matrix.device))
    
    # Combine scores with random weights and nonlinear activation
    score1 = (torch.tanh(normalized_distance) + load_scores + length_scores) * rand_weights
    score2 = torch.relu(torch.exp(normalized_distance)) + rand_weights
    heuristic_scores = score1 * time_window_scores - score2

    # Normalization of scores
    heuristic_scores -= heuristic_scores.min(dim=1, keepdim=True).values
    heuristic_scores /= (heuristic_scores.max(dim=1, keepdim=True).values + 1e-6)

    return heuristic_scores
```
